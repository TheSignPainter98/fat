local *

import log from require 'fat.logger'

spec_fns = nil
failed = false

export spec = (fn) ->
  if not spec_fns?
    spec_fns = {}
  spec_fns[] = fn

root_spec = nil
current_spec = nil
current_spec_kind = 'describe'
export describe = (what, fn) ->
  declare_spec_section 'describe', what, fn

export it = (what, fn) ->
  declare_spec_section 'it', what, fn

declare_spec_section = (kind, what, fn) ->
  if not root_spec?
    root_spec = Spec::root!
  if not current_spec?
    current_spec = root_spec

  if current_spec.kind != 'describe'
    error "cannot use `#{kind}` in `#{current_spec.kind}` spec"

  switch kind
    when 'describe'
      parent_spec = current_spec

      current_spec = Spec kind, what, parent_spec
      fn!

      parent_spec\add_child current_spec
      current_spec = parent_spec
    when 'it'
      current_spec\add_child Test what, fn, current_spec
    else
      error "internal error: unknown kind #{repr kind}"

class Spec
  @root: =>
    Spec 'describe', nil, nil

  new: (@kind, @name, @parent) =>
    @children = {}

  add_child: (child) =>
    @children[] = child

  desc: =>
    rev_parts = with {@name}
      spec = @parent
      while spec?
        [] = spec.name
        spec = spec.parent
    parts = with {}
      n = #rev_parts
      for i = 1, n
        [i] = rev_parts[n - i + 1]
    table.concat parts, ' '

  test: =>
    log ->
      if @name?
        "testing #{@desc!}..."
      else
        "running test suite..."
    for child in *@children
      child\test!

FATAL_TEST_ERROR_MARKER = 'INTERNAL ERROR: FATAL TEST ERROR'

class Test
  new: (@name, @assertions_fn, @spec) =>

  @output_test_failure_header: true
  @current_run_failures: {}

  test: =>
    @@current_run_failures = {}
    try
      @assertions_fn!
    catch err
      if not err\match FATAL_TEST_ERROR_MARKER
        Test::fail "caught error: #{err}"

    if #@@current_run_failures == 0
      return

    if @@output_test_failure_header
      print 'SOME TESTS FAILED:'
      @@output_test_failure_header = false

    print "* #{@spec\desc!} #{@name}:"
    for failure in *@@current_run_failures
      print "  * #{reflow '    ', failure}"

  @fail: (cause, message) =>
    cause_string = switch type cause
      when 'string'
        cause
      when 'table'
        { :value_name, :expected, :actual_repr, :explanation } = cause
        "for value: #{value_name}\nexpected: #{expected}\nactual: #{actual_repr},\n  #{reflow '  ', explanation, 70}"
      else
        error "internal error: invalid matcher return: #{repr cause}"
    if message?
      @@current_run_failures[] = "#{message}: #{cause_string}"
    else
      @@current_run_failures[] = cause_string

  @fatal: (value_name, cause, message) =>
    @@fail value_name, cause, message
    error FATAL_TEST_ERROR_MARKER

export expect_that = (value_name, actual, matcher) ->
  if matcher\matches actual
    return

  Test::fail
    :value_name
    expected: matcher\describe!
    actual_repr: matcher\actual_repr?! ?? repr actual
    explanation: matcher\explain_match actual

export assert_that = (value_name, actual, matcher) ->
  if matcher\matches actual
    return

  Test::fatal
    :value_name
    expected: matcher\describe!
    actual_repr: matcher.actual_repr?! ?? repr actual
    explanation: matcher\explain_match actual

class Anything
  matches: (actual) =>
    true

  explain_match: (actual) =>
    "which #{@describe!}"

  describe: (is_match=true) =>
    "is anything"

class Not
  new: (@inner) =>

  matches: (actual) =>
    not @inner\matches actual

  explain_match: (actual) =>
    @inner\explain_match actual

  describe: (is_match=true) =>
    @inner\describe not is_match

class Eq
  new: (@expected) =>

  matches: (actual) =>
    @expected == actual

  explain_match: (actual) =>
    "which #{@describe @matches actual}"

  describe: (is_match=true) =>
    if is_match
      "is equal to #{repr @expected}"
    else
      "isn't equal to #{repr @expected}"

class Compare
  new: (@kind, @value) =>

  matches: (actual) =>
    switch @kind
      when '=='
        actual == @value
      when '<'
        actual < @value
      when '<='
        actual <= @value
      when '>'
        actual > @value
      when '>='
        actual >= @value
      else
        error "internal error: unrecognised comparison: #{repr @kind}"

  explain_match: (actual) =>
    "which #{@describe @matches actual}"

  describe: (is_match=true) =>
    comparison_name = switch @kind
      when '=='
        "equal to"
      when '<'
        "less than"
      when '<='
        "at most"
      when '>'
        "greater than"
      when '>='
        "at least"
      else
        error "internal error: unrecognised comparison: #{repr @kind}"
    if is_match
      "is #{comparison_name} #{repr @value}"
    else
      "isn't #{comparison_name} #{repr @value}"


class DeepEq
  new: (@expected) =>

  matches: (actual) =>
    @deep_equal @expected, actual

  deep_equal: (a, b) =>
    if a == b
      return true

    type_a = type a
    type_b = type b
    if type_a != type_b
      return false

    if type_a != 'table'
      return false
    for ka, va in pairs a
      vb = b[ka]
      if not @deep_equal va, vb
        return false
    for kb, _ in pairs b
      if not a[kb]
        return false
    true

  explain_match: (actual) =>
    "which #{@describe @matches actual}"

  describe: (is_match=true) =>
    if is_match
      "is deeply equal to #{repr @expected}"
    else
      "isn't deeply equal to #{repr @expected}"

class Matches
  new: (@pat) =>

  matches: (actual) =>
    (actual\match @pat)?

  explain_match: (actual) =>
    "which #{@describe @matches actual}"

  describe: (is_match=true) =>
    if is_match
      "matches #{repr @pat}"
    else
      "doesn't match #{repr @pat}"

class Len
  new: (@inner) =>

  matches: (actual) =>
    @inner\matches #actual

  explain_match: (actual) =>
    "which has length #{#actual} #{@inner\explain_match #actual}"

  describe: (is_match=true) =>
    if is_match
      "has a length which #{@inner\describe!}"
    else
      "doesn't have a length which #{@inner\describe!}"

class ToStringsAs
  new: (@inner) =>

  matches: (actual) =>
    @inner\matches tostring actual

  explain_match: (actual) =>
    tostring_actual = tostring actual
    "which tostrings as '#{tostring_actual}' #{@inner\explain_match tostring_actual}"

  describe: (is_match=true) =>
    if is_match
      "tostrings as a string which #{@inner\describe true}"
    else
      "doesn't tostrings as a string which #{@inner\describe false}"

class Err
  new: (@inner) =>
    @actual_set = false
    @actual = nil

  actual_repr: =>
    if @actual?
      "error #{repr @actual}"
    else
      "no error thrown"

  get_err: (fn) =>
    if @actual_set
      return @actual

    local err
    try
      fn!
    catch err2
      err = err2
    @actual = err
    @actual_set = true
    return err

  matches: (fn) =>
    err = @get_err fn
    if not err?
      return false
    @inner\matches err

  explain_match: (fn) =>
    @get_err fn
    "which throws #{@actual_repr!} #{@inner\explain_match err}"

  describe: (is_match=true) =>
    if @actual_set -- is_match
      "throws an error which #{@inner\describe!}"
    else
      "doesn't throw an error"

class Contains
  new: (@kind, @inner) =>
    @pretty_kind = if @kind == 'key-value'
      'key-value pair'
    else
      @kind

  matches: (actual) =>
    (@find_match actual)?

  find_match: (actual) =>
    for key, value in pairs actual
      to_check = switch @kind
        when 'key'
          key
        when 'value'
          value
        when 'key-value'
          :key, :value
        else
          error "internal error: unknown kind #{repr @kind}"
      if @inner\matches to_check
        return to_check
    nil

  explain_match: (actual) =>
    if match = @find_match actual
      "which contains #{repr match} #{@inner\explain_match match}"
    else
      "which does not contain any #{@pretty_kind} which #{@inner\describe!}"

  describe: (is_match=true) =>
    if is_match
      "contains a value which #{@inner\describe!}"
    else
      "does not contain any #{@pretty_kind} which #{@inner\describe!}"

class Each
  new: (@kind, @inner) =>

  matches: (actual) =>
    not (@find_non_match actual)?

  find_non_match: (actual) =>
    for key, value in pairs actual
      to_check = switch @kind
        when 'key'
          key
        when 'value'
          value
        when 'key-value'
          :key, :value
        else
          error "internal error: unknown kind #{repr @kind}"
      if not @inner\matches to_check
        return to_check
    nil

  explain_match: (actual) =>
    non_match = @find_non_match actual
    if not non_match?
      "in which each element #{@inner\describe true}"
    else
      "in which some element #{@inner\describe false}"

  describe: (is_match=true) =>
    if is_match
      "contains a value which #{@inner\describe!}"
    else
      "does not contain any value which #{@inner\describe!}"

repr = (value) ->
  table.concat with {}
    stack={}
    repr_impl = (value) ->
      for elem in *stack
        if rawequal value, elem
          [] = '...'
      stack[] = value

      switch type value
        when 'string'
          [] = "'#{value}'"
        when 'table'
          if table.<>? and table.<tostring>?
            [] = tostring table
          else if is_list value
            [] = '['
            first = true
            for elem in *value
              if not first
                [] = ', '
              first = false

              repr_impl elem
            [] = ']'
          else
            [] = '{'
            first = true
            for k, v in pairs value
              if not first
                [] = ', '
              first = false

              repr_impl k
              [] = ': '
              repr_impl v
            [] = '}'
        else
          [] = tostring value

      stack[#stack] = nil
    repr_impl value

is_list = (table) ->
  max_key = 0
  num_keys = 0
  for k, _ in pairs table
    num_keys += 1
    if 'number' != type k
      return false
    if max_key < k
      max_key = k
  max_key == num_keys and num_keys > 0

export matchers =
  anything: -> Anything!
  not_: (matcher) -> Not matcher
  eq: (value) -> Compare '==', value
  deep_eq: (value) -> DeepEq value
  lt: (value) -> Compare '<', value
  le: (value) -> Compare '<=', value
  gt: (value) -> Compare '>', value
  ge: (value) -> Compare '>=', value
  len: (matcher) -> Len matcher
  matches: (pattern) -> Matches pattern
  tostrings_as: (matcher) -> ToStringsAs matcher
  contains_key: (matcher) -> Contains 'key', matcher
  contains_value: (matcher) -> Contains 'value', matcher
  contains_pair: (matcher) -> Contains 'key-value', matcher
  each_key: (matcher) -> Each 'key', matcher
  each_value: (matcher) -> Each 'value', matcher
  each_pair: (matcher) -> Each 'key-value', matcher
  err: (matcher) -> Err matcher

reflow = (prefix, string, width=80) ->
  lines = with {}
    chunk_len = width - #prefix
    first_line = true
    for line in string\gmatch '[^\r\n]*'
      for i = 1, #line, chunk_len
        chunk = line\sub i, i + chunk_len - 1
        if first_line
          [] = chunk
        else
          [] = prefix .. chunk
        first_line = false
  table.concat lines, '\n'

export run_tests = ->
  -- Gather specs
  if not spec_fns?
    return
  for spec_fn in *spec_fns
    spec_fn!

  root_spec?\test!

  if failed
    error "some checks failed"
