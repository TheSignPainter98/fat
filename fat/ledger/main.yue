local *

import Flag, Subcommand from require 'clap'
import Queue from require 'fat.data.queue'
import parse_toml from require 'fat.toml'
import declare_type, F, T from require 'quicktype'
import spec from require 'spec'

export subcommand = with Subcommand 'ledger'
  \description 'show system status log'
  \add with Flag 'show-history'
    \short nil
    \description 'at the start, print all history'

export main = F '({}) -> <>', (args) ->
  term_width, term_height = term?.getSize!
  term_width ??= 80
  term_height ??= 20

  ledger = Ledger term_height - 1
  ledger\add { 'hello', 'world', 'hfjdkla' }
  ledger\add { 'hello2', 'world', 'hfjdkla' }
  ledger\add { 'hello3', 'world', 'hfjdkla' }
  ledger\emit
    max_rows: term_height - 1
    width: term_width

declare_type 'Ledger', [[{
  entries: {
    iter: () => thread,
  },
}]]
declare_type 'Entry', [[{
  when: string,
  what: string,
  how: string,
}]]
class Ledger
  @save_path: '.ledger-state.toml'

  new: F '(number) => <>', (@max_len) =>
    @entries = Queue!

  load: F '(?string) => <>', (path=@@save_path) =>
    local content
    with assert io.open path, 'r'
      content = assert \read '*a'
      assert \close!
    data = parse_toml content

    @max_len = T 'number', assert data.max_len, 'saved ledger missing max_len field'
    entries = T '[Entry]', assert data.entries, 'saved ledger missing entries array'
    @entries = Queue!
    for entry in *entries
      @entries\add entry

  save: F '(?string) => <>', (path=@@save_path) =>
    lines = with {}
      [] = "max_len = #{max_len}"
      for entry in *@entries
        [] = '[[entries]]'
        [] = "what = '#{entry[1]}'"
        [] = "when = '#{entry[2]}'"
        [] = "how = '#{entry[3]}'"
        [] = ''
    to_write = table.concat lines, '\n'

    with assert io.open 'w+'
      assert \write to_write
      assert \close!

  len: F '() => number', =>
    @entries\len!

  add: F '(Entry) => <>', (entry) =>
    if @entries\len! == @max_len
      @entries\dequeue!
    @entries\enqueue entry

  emit: F '(?LedgerFmtOpts) => <>', (opts={}) =>
    to_print = @fmt opts

    term?.clear!
    print to_print
    return

  fmt: F '(LedgerFmtOpts) => string', (opts) =>
    buf = {}
    @fmt_header buf, opts
    @fmt_body buf, opts
    table.concat buf, '\n'

  fmt_header: F '([string], LedgerFmtOpts) => <>', (buf, opts) =>
    @fmt_entry buf, { 'when', 'what', 'how' }, opts

  fmt_body: F '([string], LedgerFmtOpts) => <>', (buf, opts) =>
    { :max_rows } = opts

    len = @len!
    if len == 0
      buf[] = "--- ledger empty ---"
      return
    if max_rows > len
      max_rows = len
    entries = [ entry for entry in @entries\iter! ]
    for entry in *entries[#entries,1,-1]
      @fmt_entry buf, entry, opts

  fmt_entry: F '([string], Entry, ?LedgerFmtOpts) => <>', (buf, entry, opts={}) =>
    { :width } = opts

    columns = { entry.when, entry.what, entry.how }

    sep = '  '
    column_widths =
      * 15
      * 10
    final_column_width = width - (sum column_widths) - #sep * #column_widths
    if final_column_width < 0
      error "cannot display entry in width of #{width} chars, need at least #{sum column_widths + #sep * (#column_widths - 1)}"
    column_widths[] = final_column_width
    assert #column_widths == #columns, 'internal error: different number columns and column widths'

    cells = [ fmt_cell columns[i], column_widths[i] for i = 1, #columns ]
    buf[] = table.concat cells, sep

declare_type 'LedgerFmtOpts', [[{
  max_rows: number,
  width: number,
}]]

sum = F '([number]) -> number', (ns) ->
  tot = 0
  for n in *ns
    tot += n
  tot

fmt_cell = F '(string, number) -> string', (string, width) ->
  if #string == width
    string
  else if #string < width
    "%-#{width}s"\format string
  else
    "#{string\sub 1, width - 3}..."

spec ->
  import assert_that, describe, expect_that, it, matchers from require 'spec'
  import deep_eq, eq from matchers

  describe 'Ledger', ->
    it 'rotates its content', ->
      LEN = 3
      ledger = Ledger LEN
      for i = 1, LEN
        ledger\add when: 'hello', what: 'world', how: tostring i
      assert_that ledger\len!, eq LEN

      expect_that [ entry for entry in ledger.entries\iter! ], deep_eq
        * when: 'hello', what: 'world', how: '1'
        * when: 'hello', what: 'world', how: '2'
        * when: 'hello', what: 'world', how: '3'

      ledger\add when: 'hello', what: 'world', how: 'NEW'
      expect_that [ entry for entry in ledger.entries\iter! ], deep_eq
        * when: 'hello', what: 'world', how: '2'
        * when: 'hello', what: 'world', how: '3'
        * when: 'hello', what: 'world', how: 'NEW'

  describe 'fmt_cell', ->
    it 'preserves right-size input', ->
      expect_that (fmt_cell 'xxx', 3), eq "xxx"

    it 'pads too-small input', ->
      expect_that (fmt_cell 'xxx', 6), eq "xxx   "

    it 'truncates too-large input', ->
      expect_that (fmt_cell 'xxxxxx', 5), eq "xx..."

  describe 'sum', ->
    it 'adds given values', ->
      expect_that (sum {1, 2, 3, 4, 5}), eq 15

    it 'handles no values', ->
      expect_that (sum {}), eq 0
