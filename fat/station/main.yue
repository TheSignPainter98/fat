local *

import Flag, Subcommand from require 'clap'
import log from require 'fat.logger'
import Platform from require 'fat.peripheral.platform'
import Stockpile from require 'fat.peripheral.stockpile'
import Packet, Uplink from require 'fat.peripheral.uplink'
import declare_type, F from require 'quicktype'
import spec from require 'spec'

export default_config = [=[
[station]
name = '<station-name>'

[[platforms]]
name = '<platform-name>'
# produces = '<resource-name>'
# consumes = '<resource-name>'
]=]

export main = F '({}) -> <>', (config) ->
  print 'starting station'
  with Station config, {Platform!}, Stockpile!, Uplink!
    \run!

class Station
  new: F '({}, [Platform], Stockpile, Uplink) => <>', (@config, @platforms, @stockpile, @uplink) =>

  run: F '() => !', =>
    while true
      @step!

  step: F '() => <>', =>
    from_id, message = @uplink\receive_from_any!
    if not from_id?
      return

    switch message\protocol!
      when 'StockpileRequest'
        @on_stockpile_request from_id, message
      when 'ScheduleRequest'
        @on_schedule_request from_id, message
      when 'InfoRequest'
        @on_info_request from_id, message
      else
        print "ignoring #{message\protocol!} message"

  on_stockpile_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling stockpile request'

    info = @stockpile\info!
    @uplink\send_to requester, StockpileResponse info

  on_schedule_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling schedule request'
    error 'todo'

  on_info_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling info request'
    error 'todo'

class StockpileRequest extends Packet

class StockpileResponse extends Packet
  new: F '(StockpileInfo) => <>', (@info) =>

class ScheduleRequest extends Packet
  new: F '(Schedule) => <>', (@schedule) =>

class ScheduleResponse extends Packet
  new: F '(?string) => <>', (@error_reason) =>

class InfoRequest extends Packet

class InfoResponse extends Packet
  new: F '(StationInfo) => <>', (@info) =>

spec ->
  import TestPlatformBackend from require 'fat.peripheral.platform'
  import TestStockpileBackend from require 'fat.peripheral.stockpile'
  import TestUplinkBackend from require 'fat.peripheral.uplink'
  import assert_that, describe, expect_that, it, matchers from require 'spec'
  import eq, has_fields, len from matchers

  describe 'Station', ->
    it 'responds to stockpile requests', ->
      sent = {}
      SERVER_ID = 12345

      config =
        station: {}
      platforms = {Platform TestPlatformBackend!}
      stockpile = Stockpile TestStockpileBackend
        size: => 1
        slot_content: (i) =>
          assert_that i, eq 1
          count: 32, displayName: 'Stone Bricks'
        slot_capacity: (i) =>
          assert_that i, eq 1
          64
      uplink = Uplink TestUplinkBackend
        receive: (_, _) =>
          @count ??= 1
          if @count == 1
            @count += 1
            return SERVER_ID, {}, 'StockpileRequest'
          nil, nil, nil
        send: (recipient, message, protocol) =>
          sent[] = :recipient, :message, :protocol
          true
      station = Station config, platforms, stockpile, uplink

      for _ = 1, 10
        station\step!

      expect_that sent, len eq 1

      expect_that sent[1], has_fields
        recipient: eq SERVER_ID
        message: has_fields
          info: has_fields
            item: eq 'Stone Bricks'
            stored: eq 32
            capacity: eq 64
        protocol: eq 'StockpileResponse'
