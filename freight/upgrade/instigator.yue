local *
local MarshalBumpVersion -- TODO(kcza): move me

import log from require 'freight.logger'
import IdempotenceToken, Packet, TIMEOUT, Uplink from require 'freight.peripheral.uplink'
import MinecraftRebooter, RebootRequest from require 'freight.upgrade.rebooter'
import Tester from require 'freight.upgrade.tester'
import F from require 'quicktype'
import spec from require 'spec'

export class Instigator using Tester
  new: F '(?{}, Release, ?Uplink, ?Rebooter) => <>', (@config, @release, @uplink=Uplink!, @rebooter=MinecraftRebooter!) =>
    if config?.marshal?
      error 'cannot instigate upgrade from marshal computer'

  upgrade: F '(?boolean) => <>', (prompt=true) =>
    assert @test @release

    if prompt
      local resp
      while resp != ''
        print 'press [ENTER] to deploy upgrade'
        resp = io.read '*l'
    @bump_marshal @release

    if @await_reboot_request!
      @reboot!

  -- prime_local: F '(string) => <boolean, ?string>', (release) =>
  --   log -> 'priming local...'
  --   if not @fs\exists TMP_DIR
  --     @fs\mkdir TMP_DIR
  --   @fs\write "#{TMP_DIR}/freight", release
  --   true, nil

  -- prepare_remotes: F '({number->string}, string) => <boolean, ?string>', (remotes, release) =>
  --   log -> 'preparing remote instances'
  --
  --   idemp_tok = IdempotenceToken!
  --   @uplink\broadcast PrepareUpgradeRequest idemp_tok, release
  --   responses = @collect_responses 1, PrepareUpgradeResponse, F '(Packet) -> boolean', (packet) ->
  --     packet.idemp_tok == idemp_tok
  --
  --   true, nil

  -- get_remotes: F '() => {number -> string}', =>
  --   log -> 'finding remotes...'
  --
  --   idemp_tok = IdempotenceToken!
  --   @uplink\broadcast DeclareSelfRequest idemp_tok
  --   responses = @collect_responses 1, DeclareSelfResponse, F '(Packet) -> boolean', (packet) ->
  --     packet.idemp_tok == idemp_tok
  --
  --   { from_id, packet for { :from_id, packet: { :name } } in *responses }

  -- collect_responses: F '(number, Packet, (Packet) -> boolean) => [Packet]', (packet_type, window_seconds, filter) =>
  --   with {}
  --     abort = false
  --     parallel.waitForAny
  --       * ->
  --         os.sleep window_seconds
  --       * ->
  --         while not abort
  --           from_id, packet_or_error = @uplink\receive_from_any packet_type
  --           if not from_id?
  --             if packet_or_error == TIMEOUT
  --               continue
  --             error packet_or_error
  --
  --           if filter? and not filter packet_or_error
  --             continue
  --           [] = :from_id, packet: packet_or_error
  --     abort = true

  -- transition_local: F '() => <boolean, ?string>', =>
  --   local err
  --   try
  --     @fs\move "#{TMP_DIR}/freight", 'freight'
  --   catch err2
  --     err = err2
  --   not err?, err

  bump_marshal: F '(Release) => <>', (release) =>
    log -> 'bumping marshal...'
    @uplink\broadcast MarshalBumpVersion release
    return

  await_reboot_request: F '() => boolean', =>
    log -> 'awaiting reboot request...'
    MAX_ATTEMPTS = 3
    for i = 1, MAX_ATTEMPTS
      print "awaiting reboot request (attempt #{i}/#{MAX_ATTEMPTS})"
      ok, err = @uplink\receive_from_any RebootRequest, timeout: 5
      if ok
        return true
      if err != TIMEOUT
        error err
    print "marshal did not issue reboot request"
    false

  reboot: F '() => !', =>
    log -> 'rebooting...'
    @rebooter\reboot!

export class MarshalBumpVersion extends Packet
  new: F '(Release) => <>', (@release) =>

spec ->
  import TestUplinkBackend from require 'freight.peripheral.uplink'
  import describe, expect_that, it, matchers from require 'spec'
  import deep_eq, errors, matches from matchers

  -- class TestBinarySourceBackend
  --   new: F '({string->string}) => <>', (@files) =>
  --
  --   get_file: F '(string) => <?string, ?string>', (file) =>
  --     content = @files[file]
  --     if content?
  --       content, nil
  --     else
  --       nil, "no such file: #{file}"
  --
  -- class TestFSBackend
  --   new: F '() => <>', =>
  --     @fs = {}
  --
  --   read: F '(string) -> <?string, ?string>', (file) =>
  --     entry = @fs[file]
  --     if not entry?
  --       return nil, "no such file or directory: #{file}"
  --     if entry.kind == 'dir'
  --       return nil, "cannot read directory: #{file}"
  --     if entry.kind != 'file'
  --       error "internal error: unknown entry kind: #{entry.kind}"
  --     dir = file\gmatch '^(.*)/[^/]*'
  --     if not @fs[dir]?
  --       return nil, "directory does not yet exist: #{dir}"
  --     entry.content, nil
  --
  --   write: F '(string, string) => <>', (file, content) =>
  --     @fs[file] = kind: 'file', :content
  --
  --   mkdir: F '(string) => <>', (path) =>
  --     @fs[path] = kind: 'dir'
  --
  --   exists: F '(string) => boolean', (path) =>
  --     @fs[path]?
  --
  --   move: F '(string, string) => <>', (src, dest) =>
  --     if not @fs[src]?
  --       error "no such file or directory: #{src}"
  --     @fs[dest] = @fs[src]
  --     @fs[src] = nil

  class TestRebooter
    @marker: 'REBOOTING'

    reboot: =>
      error @@marker

  describe 'Instigator', ->
    it 'instigates valid updates', ->
      cfg = {}
      release =
        file: 'freight'
        version: '9999999999999999'
        content: 'print("hello, world!")'

      sent = {}
      broadcasted = {}
      last_idemp_tok = nil
      uplink = Uplink TestUplinkBackend
        send: (id, packet, protocol) =>
          send[] = :id, :packet, :protocol
          last_idemp_tok = packet.idemp_tok
          true
        receive: do
          i = 0
          (protocol, id) =>
            i += 1
            1, RebootRequest!, RebootRequest\protocol!
        broadcast: (packet, protocol) ->
          broadcasted[] = :packet, :protocol

      rebooter = TestRebooter!
      upgrader = with Instigator cfg, release, uplink, rebooter
        expect_that (-> \upgrade false), errors matches TestRebooter.marker
