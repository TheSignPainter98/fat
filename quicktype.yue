local *
local Parser

import spec, repr from require 'spec'

export typed = (type_spec, value) ->
  if not type_spec?
    error 'cannot typecheck: no type spec provided'

  checker = type_checker type_spec
  check checker, value

type_checkers = {}
type_checker = (type_spec) ->
  type_checkers[type_spec] ?? do
    -- Slow path: parse and generate checker
    parsed_type = parse type_spec
    checker = parsed_type\checker!

    type_checkers[type_spec] = checker
    validate checker
    print "got checker:\n#{repr checker}"
    checker

parse = (type_spec) ->
  type_spec_parser = TypeSpecParser Lexer type_spec
  type_spec_parser\parse!

class Parser
  new: (@lexer) =>
  parse: =>
    error 'unimplemented'

  parse_repeat_separated: (elem_parser, sep_token) =>
    with {}
      [] = elem_parser!
      while @lexer\peek!.type == sep_token
        @lexer\next!
        [] = elem_parser!

  expect: (expected_token) =>
    token = @lexer\next!
    if not token?
      error "unexpected EOF"
    if token.type != expected_token
      error "expected #{expected_token}"
    token.value ?? token.type

  maybe: (expected_token) =>
    token = @lexer\peek!
    if not token?
      return nil
    if token.type != expected_token
      return nil
    @lexer\next!
    token.value ?? token.type

  select: (options) =>
    next_token = @lexer\peek!

    i = 1
    while options[i]
      option = options[i]
      if option.token == next_token.type
        return if action = option.action
          action!
        else
          option.token
      i += 1

    if options.otherwise?
      return options.otherwise!

    options_repr = table.concat [ tostring option.token for option in *options ], ', '
    error "expected one of #{options_repr}, got #{next_token.type}"

  sequence: (expected_tokens) =>
    with {}
      for { token: expected_token, :action } in *expected_tokens
        if expected_token?
          token = @lexer\next!
          if not token?
            error "unexpected EOF"
          if token.type != expected_token
            error "expected #{expected_token}, got #{token.type}"
          [] = token.value ?? 0
        else if action?
          [] = action!
        else
          error "sequence element must have expected_token or action"

class TypeSpecParser extends Parser

  parse: =>
    @parse_type!

  parse_type: =>
    @select
      * token: T_NAME
        action: @\parse_named_type
      * token: T_BRACKET_OPEN
        action: @\parse_list
      * token: T_PAREN_OPEN
        action: @\parse_tuple_or_function
      * token: T_BRACE_OPEN
        action: @\parse_table

  parse_named_type: =>
    named_type @expect T_NAME

  parse_list: =>
    {_, elem_type, _} = @sequence
      * token: T_BRACKET_OPEN
      * action: @\parse_type
      * token: T_BRACKET_CLOSE
    List elem_type

  parse_tuple_or_function: =>
    @expect T_PAREN_OPEN
    local types
    if @maybe T_PAREN_CLOSE
      types = {}
    else
      {types, _} = @sequence
        * action: -> @parse_repeat_separated @\parse_type, T_COMMA
        * token: T_PAREN_CLOSE
    if not @maybe T_ARROW
      return Tuple types

    return_type = @parse_type!
    if return_type.name? and return_type.name == 'nil'
      return_type = nil
    Function types, {return_type}

  parse_table: =>
    {_, table, _} = @sequence
      * token: T_BRACE_OPEN
      * action: @\parse_table_content
      * token: T_BRACE_CLOSE
    table

  parse_table_content: =>
    first_elem = @select
      * token: T_NAME
        action: -> @expect T_NAME
      * token: T_BRACE_CLOSE
        action: -> nil
      otherwise: @\parse_type
    if first_elem == nil
      return Struct {}

    second_elem = @select
      * token: T_BRACE_CLOSE
        action: -> 'set'
      * token: T_ARROW
        action: -> 'mapping'
      * token: T_COLON
        action: -> 'struct'

    switch second_elem
      when 'set'
        if 'string' == type first_elem
          first_elem = named_type first_elem
        Set first_elem
      when 'mapping'
        if 'string' == type first_elem
          first_elem = named_type first_elem
        { _, maps_to } = @sequence
          * token: T_ARROW
          * action: @\parse_type
        Mapping first_elem, maps_to
      when 'struct'
        @expect T_COLON
        first_type = @parse_type!
        first_field = Field first_elem, first_type
        if @lexer\peek!.type == T_COMMA
          @expect T_COMMA
        remainder = @select
          * token: T_BRACE_CLOSE
            action: -> nil
          * token: T_NAME
            action: -> @parse_repeat_separated @\parse_field, T_COMMA
        if remainder?
          Struct { first_field, ...remainder}
        else
          Struct { first_field }
      else
        error "internal error: unexpected symbol: #{repr second_elem}"

  parse_field: =>
    {name, _, type} = @sequence
      * token: T_NAME
      * token: T_COLON
      * action: @\parse_type
    Field name, type

-- Tokens
T_PAREN_OPEN = <tostring>: => "'('"
T_PAREN_CLOSE = <tostring>: => "')'"
T_BRACE_OPEN = <tostring>: => "'{'"
T_BRACE_CLOSE = <tostring>: => "'}'"
T_BRACKET_OPEN = <tostring>: => "'['"
T_BRACKET_CLOSE = <tostring>: => "']'"
T_COMMA = <tostring>: => "','"
T_COLON = <tostring>: => "':'"
T_ARROW = <tostring>: => "'->'"
T_NAME = <tostring>: => "<name>"

class Lexer
  new: (type_spec) =>
    @index = 1
    @done = false
    @peeked = nil
    @tokens = coroutine.wrap ->
      while @index <= #type_spec
        ty, value, bytes_consumed = if whitespace = type_spec\match '^[ \t\r\n]+', @index
          nil, nil, #whitespace
        else if match = type_spec\match '^%(', @index
          T_PAREN_OPEN, nil, #match
        else if match = type_spec\match '^%)', @index
          T_PAREN_CLOSE, nil, #match
        else if match = type_spec\match '^,', @index
          T_COMMA, nil, #match
        else if match = type_spec\match '^{', @index
          T_BRACE_OPEN, nil, #match
        else if match = type_spec\match '^}', @index
          T_BRACE_CLOSE, nil, #match
        else if match = type_spec\match '^%[', @index
          T_BRACKET_OPEN, nil, #match
        else if match = type_spec\match '^]', @index
          T_BRACKET_CLOSE, nil, #match
        else if match = type_spec\match '^:', @index
          T_COLON, nil, #match
        else if match = type_spec\match '^->', @index
          T_ARROW, nil, #match
        else if name = type_spec\match '^([a-zA-Z_][a-zA-Z0-9_]*)', @index
          T_NAME, name, #name
        else
          error "unrecognised character '#{type_spec\sub @index, @index}' in type spec '#{type_spec}"

        @index += bytes_consumed
        if not ty?
          continue
        coroutine.yield Symbol ty, value

  peek: =>
    if @done
      return nil

    if @peeked?
      return @peeked

    @peeked = @tokens!
    if not @peeked
      @done = true
    @peeked

  next: =>
    if @done
      return nil

    if @peeked?
      peeked = @peeked
      @peeked = nil
      peeked
    else
      ret = @tokens!
      if not ret?
        @done = true
      ret

  snapshot: =>
    Snapshot @index, @peeked

  restore: (snapshot) =>
    { :index, :peeked } = snapshot
    @index = index
    @peeked = peeked

class Snapshot
  new: (@index, @peeked) =>

class Symbol
  new: (@type, @value=nil) =>

  __tostring: =>
    if @value?
      "#{@type}(#{@value})"
    else
      "#{@type}"

known_primitives =
  nil: true
  boolean: true
  number: true
  string: true
  function: true
  table: true
  thread: true
named_type = (name) ->
  if not name.match?
    error repr name
  if known_primitives[name]?
    Primitive name
  else if not name\match '^[A-Z]'
    error "cannot use '#{name}' as custom type name: name must start with an uppercase letter"
  else
    UserType name

class Primitive
  new: (@name) =>

  __tostring: => @name

  checker: (prog={}) =>
    with prog
      [] = C_ASSERT_PRIMITIVE
      [] = @name

class UserType
  new: (@name) =>

  __tostring: => @name

  checker: (prog={}) =>
    error 'todo'

class List
  new: (@elem_type) =>

  __tostring: =>
    "[#{@elem_type}]"

  checker: (prog={}) =>
    with prog
      [] = C_ASSERT_PRIMITIVE
      [] = 'table'
      [] = C_PUSH
      [] = 1

      loop_start = #prog
      [] = C_GET_FIELD
      [] = C_JMP_IF_NIL
      [] = LABEL_PLACEHOLDER
      loop_exit_jump_index = #prog
      @elem_type\checker prog
      [] = C_POP
      [] = C_INCR
      [] = C_JMP
      [] = loop_start

      [] = C_POP -- TODO(kcza): check stack on early exit
      [loop_exit_jump_index] = #prog


class Tuple
  new: (@elem_types) =>

  __tostring: =>
    elem_type_reprs = [ tostring elem_type for elem_type in *@elem_types ]
    "(#{table.concat elem_type_reprs, ', '})"

  checker: (prog={}) =>
    with prog
      [] = C_ASSERT_PRIMITIVE
      [] = 'table'
      for i = 1, #@elem_types
        [] = C_PUSH
        [] = i
        [] = C_GET_FIELD
        @elem_types[i]\checker prog
        [] = C_POP
        [] = C_INCR
        [] = C_POP

class Struct
  new: (@fields) =>

  __tostring: =>
    field_reprs = [ tostring field for field in *@fields ]
    "{#{table.concat field_reprs, ', '}}"

  checker: (prog={}) =>
    with prog
      [] = C_ASSERT_PRIMITIVE
      [] = 'table'
      for field in *@fields
        [] = C_PUSH
        [] = field.name
        [] = C_GET_FIELD
        field.type\checker prog
        [] = C_POP
        [] = C_POP

class Field
  new: (@name, @type) =>

  __tostring: =>
    "#{@name}: #{@type}"

  checker: (prog={}) =>
    @type\checker prog

class Set
  new: (@elem_type) =>

  __tostring: =>
    "{#{@elem_type}}"

  checker: (prog={}) =>
    error 'todo'

class Mapping
  new: (@in_type, @out_type) =>

  __tostring: =>
    "{#{@in_type} -> #{@out_type}}"

  checker: (prog={}) =>
    error 'todo'

class Function
  new: (@param_types, @return_types) =>

  __tostring: =>
    table.concat with {}
      [] = '('
      first = true
      for param_type in *@param_types
        if not first
          [] = ", "
        first = false

        [] = tostring param_type
      [] = ') -> '
      if #@return_types == 1
        [] = tostring @return_types[1]
      else
        [] = '<'
        first = true
        for return_type in *@return_types
          if not first
            [] = ", "
          first = false
          [] = tostring return_type
        [] = '>'

  checker: (prog={}) =>
    with prog
      [] = C_ASSERT_PRIMITIVE
      [] = 'function'

C_PUSH = <tostring>: => '<push>'
C_POP = <tostring>: => '<pop>'
C_ASSERT_PRIMITIVE = <tostring>: => '<assert-primitive>'
C_GET_FIELD = <tostring>: => '<field>'
C_INCR = <tostring>: => '<incr>'
C_JMP = <tostring>: => '<jmp>'
C_JMP_IF_NIL = <tostring>: => '<jnil>'

LABEL_PLACEHOLDER = <tostring>: => '<LABEL-PLACEHOLDER>'

validate = (check_prog) ->
  for instruction in *check_prog
    if instruction == LABEL_PLACEHOLDER
      error "unresolved placeholder in check program:\n#{repr check_prog}"

value_stack_size = 0
value_stack = {}
check = (check_prog, value) ->
  value_stack_size = 1
  value_stack[1] = value

  for pc = 1, #check_prog
    switch check_prog[pc]
      when C_PUSH
        pc += 1
        value = check_prog[pc]
        value_stack_size += 1
        value_stack[value_stack_size] = value
      when C_POP
        value_stack[value_stack_size] = nil
        value_stack_size -= 1
      when C_ASSERT_PRIMITIVE
        ty = type value_stack[value_stack_size]
        pc += 1
        if ty != check_prog[pc]
          error "incorrect type: expected #{check_prog[pc]} but got #{ty}"
      when C_GET_FIELD
        value_stack_size += 1
        value_stack[value_stack_size] = value_stack[value_stack_size-2][value_stack[value_stack_size-1]]
      when C_INCR
        value_stack[value_stack_size] += 1
      when C_JMP
        pc = chec_prog[pc + 1] - 1
      when C_JMP_IF_NIL
        if value_stack[value_stack_size]?
          pc = chec_prog[pc] - 1
        else
          pc += 1

export declare_type = (name, type_spec) ->
  if not (name\sub 1, 1)\match '^[A-Z_]$'
    error "cannot declare type '#{name}': custom types must start with uppercase or '_'"
  if type_checkers[name]?
    error "cannot redefine type '#{name}'"
  type_checkers[name] = type_checker name

export deactivate = ->
  typed = (_, fn) -> fn

spec ->
  import assert_that, expect_that, describe, it, matchers from require 'spec'
  import anything, contains_value, deep_eq, eq, errors, fields, len, match, matches, no_errors from matchers

  describe 'Lexer', ->
    tokens = (raw) ->
      assert raw
      with {}
        for token in (Lexer raw).tokens
          [] = token

    it 'emits simple types', ->
      simple_types =
        * type nil
        * type false
        * type 0
        * type ""
        * type ->
        * type coroutine.create ->
      for simple_type in *simple_types
        expect_that (tokens simple_type), deep_eq {
          Symbol T_NAME, simple_type
        }

    it 'emits strucural tokens', ->
      expect_that (tokens '(),{}[]:->'), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_PAREN_CLOSE
        Symbol T_COMMA
        Symbol T_BRACE_OPEN
        Symbol T_BRACE_CLOSE
        Symbol T_BRACKET_OPEN
        Symbol T_BRACKET_CLOSE
        Symbol T_COLON
        Symbol T_ARROW
      }

    it 'ignores whitespace', ->
      expect_that (tokens ' (\tstring\r)\n-> string '), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_NAME, "string"
        Symbol T_PAREN_CLOSE
        Symbol T_ARROW
        Symbol T_NAME, "string"
      }

    it 'rejects unrecognised characters', ->
      expect_that (-> tokens '@'), errors matches [[unrecognised character '@']]
      expect_that (-> tokens '1'), errors matches [[unrecognised character '1']]

    describe ':peek', ->
      it 'matches :next', ->
        lexer = Lexer '()'
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\next!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\next!, deep_eq Symbol T_PAREN_CLOSE

      it 'returns nil at EOF', ->
        lexer = Lexer ''
        expect_that lexer\peek!, eq nil
        expect_that lexer\peek!, eq nil

  describe 'Parser', ->
    describe 'run on simple types', ->
      it 'accepts primitives', ->
        expect_that (parse 'nil'), deep_eq Primitive type nil
        expect_that (parse 'number'), deep_eq Primitive type 0
        expect_that (parse 'number'), deep_eq Primitive type 0.0
        expect_that (parse 'string'), deep_eq Primitive type ""
        expect_that (parse 'table'), deep_eq Primitive type {}
        expect_that (parse 'function'), deep_eq Primitive type ->
        expect_that (parse 'thread'), deep_eq Primitive type coroutine.create ->

      it 'accepts custom types', ->
        expect_that (parse 'CustomType'), deep_eq UserType 'CustomType'

      it 'rejects unknown primitives', ->
        expect_that (-> parse 'custom'), errors matches [[cannot use 'custom' as custom type name: name must start with an uppercase letter]]

    describe 'run on composite types', ->
      it 'accepts lists', ->
        expect_that (parse '[string]'), deep_eq List Primitive 'string'
        expect_that (parse '[[string]]'), deep_eq List List Primitive 'string'

      it 'accepts tuples', ->
        expect_that (parse '()'), deep_eq Tuple {}
        expect_that (parse '(nil, number)'), deep_eq Tuple { (Primitive 'nil'), Primitive 'number' }
        expect_that (parse '((nil, number), string, (Custom, table))'), deep_eq Tuple {
          Tuple { (Primitive 'nil'), (Primitive 'number') },
          Primitive 'string',
          Tuple { (UserType 'Custom'), (Primitive 'table') },
        }

      it 'accepts sets', ->
        expect_that (parse '{string}'), deep_eq Set Primitive 'string'
        expect_that (parse '{{string}}'), deep_eq Set Set Primitive 'string'

      it 'accepts mappings', ->
        expect_that (parse '{boolean -> number}'), deep_eq Mapping (Primitive 'boolean'), Primitive 'number'
        expect_that (parse '{{boolean -> number} -> {string -> thread}}'), deep_eq Mapping (Mapping (Primitive 'boolean'), Primitive 'number'), Mapping (Primitive 'string'), Primitive 'thread'

      it 'accepts structs', ->
        expect_that (parse '{}'), deep_eq Struct {}
        expect_that (parse '{field: boolean}'), deep_eq Struct
          * Field 'field', Primitive 'boolean'
        expect_that (parse '{field1: number, field2: string}'), deep_eq Struct
          * Field 'field1', Primitive 'number'
          * Field 'field2', Primitive 'string'
        expect_that (parse '{outer1: {inner1: boolean}, outer2: {inner2: boolean}}'), deep_eq Struct
          * Field 'outer1', Struct
            * Field 'inner1', Primitive 'boolean'
          * Field 'outer2', Struct
            * Field 'inner2', Primitive 'boolean'

      it 'accepts functions', ->
        expect_that (parse '() -> nil'), deep_eq Function {}, {}
        expect_that (parse '(string) -> number'), deep_eq Function {Primitive 'string'}, {Primitive 'number'}
        expect_that (parse '(string) -> (number) -> boolean'), deep_eq Function {Primitive 'string'}, {Function {Primitive 'number'}, {Primitive 'boolean'}}

  describe 'declare_type', ->
    it 'rejects false primitives', ->
      expect_that (-> declare_type 'custom'), errors matches 'custom types must start with uppercase'

    -- it 'rejects redefinition', ->
    --   declare_type 'Custom', 'number'
    --   expect_that (-> declare_type 'Custom'), errors matches [[cannot redefine type 'Custom']]

  describe 'typed', ->
    it 'requires two arguments', ->
      expect_that (-> typed!), errors matches 'cannot typecheck: no type spec provided'

    it 'checks primitive types', ->
      expect_that (-> typed 'nil', nil), no_errors!
      expect_that (-> typed 'number', 123), no_errors!
      expect_that (-> typed 'string', 'some-string'), no_errors!

      expect_that (-> typed 'nil', 123), errors matches 'incorrect type: expected nil but got number'
      expect_that (-> typed 'number', nil), errors matches 'incorrect type: expected number but got nil'
      expect_that (-> typed 'string', 123), errors matches 'incorrect type: expected string but got number'

    it 'checks tuples', ->
      expect_that (-> typed '()', {}), no_errors!
      expect_that (-> typed '(number, boolean, string)', {123, true, 'hello'}), no_errors!
      expect_that (-> typed '(number, boolean, string)', {123, true, 'hello', coroutine.create ->}), no_errors!
      expect_that (-> typed '((number, boolean), (string, thread))', {{123, true}, {'hello', coroutine.create ->}}), no_errors!

      expect_that (-> typed '(number, boolean, string)', nil), errors matches 'incorrect type: expected table but got nil'
      expect_that (-> typed '(number, boolean, string)', {}), errors matches 'incorrect type: expected number but got nil'
      expect_that (-> typed '(number, boolean, string)', {123}), errors matches 'incorrect type: expected boolean but got nil'
      expect_that (-> typed '(number, boolean, string)', {'interloper'}), errors matches 'incorrect type: expected number but got string'

    it 'checks structs', ->
      expect_that (-> typed '{}', {}), no_errors!
      expect_that (-> typed '{}', {123}), no_errors!
      expect_that (-> typed '{}', {hello: 123}), no_errors!
      expect_that (-> typed '{hello: string}', {hello: 'hello'}), no_errors!
      expect_that (-> typed '{hello: {world: string}}', {hello: world: 'world'}), no_errors!
      expect_that (-> typed '{hello: {world: string}, foo: boolean}', hello: {world:'asdf'}, foo: true), no_errors!

      expect_that (-> typed '{}', 132), errors matches 'incorrect type: expected table but got number'
      expect_that (-> typed '{hello: string}', {}), errors matches 'incorrect type: expected string but got nil'
      expect_that (-> typed '{hello: string}', hello: 123), errors matches 'incorrect type: expected string but got number'
      expect_that (-> typed '{hello: {world: string}}', hello: 123), errors matches 'incorrect type: expected table but got number'
      expect_that (-> typed '{hello: {world: string}}', hello: {}), errors matches 'incorrect type: expected string but got nil'
      expect_that (-> typed '{hello: {world: string}}', hello: world: 123), errors matches 'incorrect type: expected string but got number'
      expect_that (-> typed '{hello: {world: string}, foo: boolean}', hello: {world:'asdf'}, foo: 123), errors matches 'incorrect type: expected boolean but got number'

    it 'checks functions', ->
      expect_that (-> typed '() -> nil', ->), no_errors!
      expect_that (-> typed '() -> nil', {}), errors matches 'incorrect type: expected function but got table'

-- import set_log_verbosity from require 'fat.logger'
-- set_log_verbosity true
(require 'spec').run_tests select 1, ...
-- TODO(kcza): optional values
