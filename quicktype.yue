local *

import spec, repr from require 'spec'

type_checkers = {}

export typed = (type_spec, value) ->
  if not type_spec?
    error 'cannot typecheck: no type spec provided'

  checker = type_checkers[type_spec] ?? do
    checker = type_checker type_spec
    type_checkers[type_spec] = checker
    checker
  error 'todo'
  -- checker_steps = type_checkers[type_spec] ?? do
  --   program = generate_checker_program type_spec
  --   type_checkers[type_spec] = program
  --   program
  -- checker = type_checker type_spec
  -- print (require 'spec').repr checker

-- Tokens
T_PAREN_OPEN = <tostring>: => "<paren_open>"
T_PAREN_CLOSE = <tostring>: => "<paren_close>"
T_BRACE_OPEN = <tostring>: => "<brace_open>"
T_BRACE_CLOSE = <tostring>: => "<brace_close>"
T_BRACKET_OPEN = <tostring>: => "<bracket_open>"
T_BRACKET_CLOSE = <tostring>: => "<bracket_close>"
T_COMMA = <tostring>: => "<comma>"
T_ARROW = <tostring>: => "<arrow>"
T_NAME = <tostring>: => "<name>"

type_checker = (type_spec) ->
  parsed_type = parse type_spec
  {} -- TODO(kcza): complete me!

parse = (type_spec) ->
  type_spec_parser = Parser Lexer type_spec
  type_spec_parser\parse!

class Parser
  new: (@lexer) =>

  parse: =>
    @parse_type!

  parse_type: =>
    @select
      * token: T_NAME
        action: @\parse_name
      * token: T_BRACKET_OPEN
        action: @\parse_list
      * token: T_PAREN_OPEN
        action: @\parse_tuple

  parse_name: =>
    name_token = @lexer\next!
    assert T_NAME == name_token.type
    name_token.value

  parse_list: =>
    {_, elem_type, _} = @sequence
      * token: T_BRACKET_OPEN
      * action: @\parse_type
      * token: T_BRACKET_CLOSE
    List elem_type

  parse_tuple: =>
    {_, elem_types, _} = @sequence
      * token: T_PAREN_OPEN
      * action: -> @parse_repeat_separated @\parse_type, T_COMMA
      * token: T_PAREN_CLOSE
    Tuple elem_types

  parse_repeat_separated: (elem_parser, sep_token) =>
    with {}
      [] = elem_parser!
      while @lexer\peek!.type == sep_token
        @lexer\next!
        [] = elem_parser!

  expect: (expected_token) =>
    token = @lexer\next!
    if not token?
      error "unexpected EOF"
    if token.type != expected_token
      error "expected #{expected_token}"
    token.value ?? 0

  select: (options) =>
    next_token = @lexer\peek!
    for option in *options
      if option.token == next_token.type
        return option.action!
    options_repr = table.concat [ tostring option.token for option in *options ], ', '
    error "expected one of #{options_repr}, got #{next_token.type}"

  sequence: (expected_tokens) =>
    with {}
      for { token: expected_token, :action } in *expected_tokens
        if expected_token?
          token = @lexer\next!
          if not token?
            error "unexpected EOF"
          if token.type != expected_token
            error "expected #{expected_token}, got #{token.type}"
          [] = token.value ?? 0
        else if action?
          [] = action!

class Lexer
  new: (type_spec) =>
    @done = false
    @peeked = nil
    @known_primitives =
      nil: true
      boolean: true
      number: true
      string: true
      function: true
      table: true
      thread: true
    @tokens = coroutine.wrap ->
      index = 1
      while index <= #type_spec
        ty, value, bytes_consumed = if whitespace = type_spec\match '^[ \t\r\n]+', index
          nil, whitespace, #whitespace
        else if type_spec\match '^%(', index
          T_PAREN_OPEN, '(', 1
        else if type_spec\match '^%)', index
          T_PAREN_CLOSE, ')', 1
        else if type_spec\match '^,', index
          T_COMMA, ',', 1
        else if type_spec\match '^{', index
          T_BRACE_OPEN, '{', 1
        else if type_spec\match '^}', index
          T_BRACE_CLOSE, '}', 1
        else if type_spec\match '^%[', index
          T_BRACKET_OPEN, '[', 1
        else if type_spec\match '^]', index
          T_BRACKET_CLOSE, ']', 1
        else if type_spec\match '^->', index
          T_ARROW, '->', 2
        else if name = type_spec\match '^([a-zA-Z_][a-zA-Z0-9_]*)', index
          if @known_primitives[name]?
            T_NAME, (Primitive name), #name
          else if not name\match '^[A-Z]'
            error "cannot use '#{name}' as custom type name: name must start with an uppercase letter"
          else
            T_NAME, (UserType name), #name
        else
          error "unrecognised character '#{type_spec\sub index, index}' in type spec '#{type_spec}"

        index += bytes_consumed
        switch ty
          when nil
            continue
          when T_NAME
            coroutine.yield Symbol ty, value
          else
            coroutine.yield Symbol ty

  peek: =>
    if @done
      return nil

    if @peeked?
      return @peeked

    @peeked = @tokens!
    if not @peeked
      @done = true
    @peeked

  next: =>
    if @done
      return nil

    if @peeked?
      peeked = @peeked
      @peeked = nil
      peeked
    else
      ret = @tokens!
      if not ret?
        @done = true
      ret

class Symbol
  new: (@type, @value=nil) =>

  __tostring: =>
    if @value?
      "#{@type}(#{@value})"
    else
      "#{@type}"

class Primitive
  new: (@name) =>

  __len: => #@name

  __tostring: => @name

class UserType
  new: (@name) =>

  __tostring: => @name

class List
  new: (@elem_type) =>

  __tostring: =>
    "[#{@elem_type}]"

class Tuple
  new: (@elem_types) =>

  __tostring: =>
    elem_type_reprs = [ tostring elem_type for elem_type in *@elem_types ]
    "(#{table.concat elem_type_reprs, ', '})"

class Function
  new: (@param_types, @return_types) =>

  __tostring: =>
    table.concat with {}
      [] = '('
      first = true
      for param_type in *@param_types
        if not first
          [] = ", "
        first = false

        [] = tostring param_type
      [] = ') -> '
      if #@return_types == 1
        [] = tostring @return_types[1]
      else
        [] = '<'
        first = true
        for return_type in *@return_types
          if not first
            [] = ", "
          first = false
          [] = tostring return_type
        [] = '>'

export declare_type = (name, type_spec) ->
  if not (name\sub 1, 1)\match '^[A-Z_]$'
    error "cannot declare type '#{name}': custom types must start with uppercase or '_'"
  if type_checkers[name]?
    error "cannot redefine type '#{name}'"
  type_checkers[name] = type_checker name

export deactivate = ->
  typed = (_, fn) -> fn

spec ->
  import assert_that, expect_that, describe, it, matchers from require 'spec'
  import anything, contains_value, deep_eq, eq, errors, fields, len, match, matches, no_errors from matchers

  describe 'Lexer', ->
    tokens = (raw) ->
      assert raw
      with {}
        for token in (Lexer raw).tokens
          [] = token

    it 'emits simple types', ->
      simple_types =
        * type nil
        * type false
        * type 0
        * type ""
        * type ->
        * type coroutine.create ->
        * type coroutine.wrap ->
      for simple_type in *simple_types
        expect_that (tokens simple_type), deep_eq {
          Symbol T_NAME, Primitive simple_type
        }

    it 'emits strucural tokens', ->
      expect_that (tokens '(),{}[]->'), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_PAREN_CLOSE
        Symbol T_COMMA
        Symbol T_BRACE_OPEN
        Symbol T_BRACE_CLOSE
        Symbol T_BRACKET_OPEN
        Symbol T_BRACKET_CLOSE
        Symbol T_ARROW
      }

    it 'ignores whitespace', ->
      expect_that (tokens ' (\tstring\r)\n-> string '), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_NAME, Primitive "string"
        Symbol T_PAREN_CLOSE
        Symbol T_ARROW
        Symbol T_NAME, Primitive "string"
      }

    it 'rejects unrecognised characters', ->
      expect_that (-> tokens '"'), errors matches [[unrecognised character '"']]
      expect_that (-> tokens '1'), errors matches [[unrecognised character '1']]

    describe ':peek', ->
      it 'matches :next', ->
        lexer = Lexer '()'
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\next!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\next!, deep_eq Symbol T_PAREN_CLOSE

      it 'returns nil at EOF', ->
        lexer = Lexer ''
        expect_that lexer\peek!, eq nil
        expect_that lexer\peek!, eq nil

  describe 'Parser', ->
    describe 'run on simple types', ->
      it 'accepts primitives', ->
        expect_that (parse 'nil'), deep_eq Primitive type nil
        expect_that (parse 'number'), deep_eq Primitive type 0
        expect_that (parse 'number'), deep_eq Primitive type 0.0
        expect_that (parse 'string'), deep_eq Primitive type ""
        expect_that (parse 'table'), deep_eq Primitive type {}
        expect_that (parse 'function'), deep_eq Primitive type ->
        expect_that (parse 'thread'), deep_eq Primitive type coroutine.create ->

      it 'accepts custom types', ->
        expect_that (parse 'CustomType'), deep_eq UserType 'CustomType'

      it 'rejects unknown primitives', ->
        expect_that (-> parse 'custom'), errors matches [[cannot use 'custom' as custom type name: name must start with an uppercase letter]]

    describe 'run on composite types', ->
      it 'accepts lists', ->
        expect_that (parse '[string]'), deep_eq List Primitive 'string'
        expect_that (parse '[[string]]'), deep_eq List List Primitive 'string'

      it 'accepts tuples', ->
        expect_that (parse '(nil, number)'), deep_eq Tuple { (Primitive 'nil'), Primitive 'number' }
        expect_that (parse '((nil, number), string, (Custom, table))'), deep_eq Tuple {
          Tuple { (Primitive 'nil'), (Primitive 'number') },
          Primitive 'string',
          Tuple { (UserType 'Custom'), (Primitive 'table') },
        }

  describe 'declare_type', ->
    it 'rejects false primitives', ->
      expect_that (-> declare_type 'custom'), errors matches 'custom types must start with uppercase'

    it 'rejects redefinition', ->
      declare_type 'Custom', 'number'
      expect_that (-> declare_type 'Custom'), errors matches [[cannot redefine type 'Custom']]

  -- describe 'typed', ->
  --   it 'requires two arguments', ->
  --     expect_that (-> typed!), errors matches 'cannot typecheck: no type spec provided'
  --   --
  --   -- it 'handles nils', ->
  --   --   expect_that (-> typed 'nil', nil), no_errors!
  --   --   expect_that (-> typed 'nil', 123), errors anything!
  --
  --   it 'handles numbers', ->
  --     expect_that (-> typed 'number', nil), errors anything!
  --     expect_that (-> typed 'number', 123), no_errors!

-- import set_log_verbosity from require 'fat.logger'
-- set_log_verbosity true
(require 'spec').run_tests select 1, ...
