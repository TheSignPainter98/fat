local *
local Parser

import spec, repr from require 'spec'

export T = (type_spec, value) ->
  if not type_spec?
    error 'cannot typecheck: no type spec provided'

  checker = type_checker type_spec
  check checker, value
  value

export DEBUG = false
export COLLECT_STATS = false

type_checkers = {}
type_checker = (type_spec) ->
  type_checkers[type_spec] ?? do
    -- Slow path: parse and generate checker
    checker = (parse type_spec)\checker!\build!

    type_checkers[type_spec] = checker
    if DEBUG
      print "got checker:\n\t#{checker_program_repr checker}"
    checker

export F = (type_spec, fn) ->
  if not type_spec?
    error 'cannot typecheck: no type spec provided'
  if 'function' != type fn
    error 'cannot typecheck: no function provided'

  fn_type = function_type type_spec

  return_types = fn_type\return_checkers!
  check_returns = (...) ->
    n_return_values = select '#', ...
    if #return_types < n_return_values
      error 'function returned too many values'
    for i = 1, #return_types
      check return_types[i], select i, ...
    ...

  param_types = fn_type\param_checkers!
  (...) ->
    if #param_types < select '#', ...
      error 'function passed too many arguments'
    for i = 1, #param_types
      check param_types[i], select i, ...
    check_returns fn ...

function_types = {}
function_type = (type_spec) ->
  function_types[type_spec] ?? do
    -- Slow path: parse type spec
    parsed_type = parse type_spec
    if parsed_type.<class>.__name != 'Function'
      error "cannot typecheck: expected a function type"

    function_types[type_spec] = parsed_type
    parsed_type

parse = (type_spec) ->
  type_spec_parser = TypeSpecParser Lexer type_spec
  type_spec_parser\parse!

class Parser
  new: (@lexer) =>
  parse: =>
    error 'unimplemented'

  parse_repeat_separated: (elem_parser, sep_token) =>
    with {}
      [] = elem_parser!
      tok = @lexer\peek!
      while tok? and tok.type == sep_token
        @lexer\next!
        [] = elem_parser!
        tok = @lexer\peek!

  expect: (expected_token) =>
    token = @lexer\next!
    if not token?
      error "unexpected EOF"
    if token.type != expected_token
      error "expected #{expected_token}"
    token.value ?? token.type

  maybe: (expected_token) =>
    token = @lexer\peek!
    if not token?
      return nil
    if token.type != expected_token
      return nil
    @lexer\next!
    token.value ?? token.type

  select: (options) =>
    next_token = @lexer\peek!
    if not next_token?
      error "unexpected EOF"

    i = 1
    while options[i]
      option = options[i]
      if option.token == next_token.type
        return if action = option.action
          action!
        else
          option.token
      i += 1

    if options.otherwise?
      return options.otherwise!

    options_repr = table.concat [ tostring option.token for option in *options ], ', '
    error "expected one of #{options_repr}, got #{next_token.type}"

  sequence: (expected_tokens) =>
    with {}
      for { token: expected_token, :action } in *expected_tokens
        if expected_token?
          token = @lexer\next!
          if not token?
            error "unexpected EOF"
          if token.type != expected_token
            error "expected #{expected_token}, got #{token.type}"
          [] = token.value ?? 0
        else if action?
          [] = action!
        else
          error "sequence element must have expected_token or action"

class TypeSpecParser extends Parser
  parse: =>
    ret = @parse_type!
    if @lexer\peek!
      error 'type spec has trailing characters'
    ret

  parse_type: =>
    @parse_type_disjunction!

  parse_type_disjunction: =>
    disjunction = @parse_repeat_separated @\parse_type_conjunction, T_PIPE
    if #disjunction == 1
      disjunction[1] -- Single element
    else
      Disjunction disjunction

  parse_type_conjunction: =>
    conjunction = @parse_repeat_separated @\parse_optional_type, T_PLUS
    if #conjunction == 1
      conjunction[1] -- Single element
    else
      Conjunction conjunction

  parse_optional_type: =>
    @select
      * token: T_QUESTION
        action: ->
          @expect T_QUESTION
          Optional @parse_specific_type!
      otherwise: ->
        @parse_specific_type!

  parse_specific_type: =>
    @select
      * token: T_NAME
        action: @\parse_named_type
      * token: T_STRING
        action: @\parse_string_type
      * token: T_BRACKET_OPEN
        action: @\parse_array
      * token: T_PAREN_OPEN
        action: @\parse_tuple_or_function
      * token: T_BRACE_OPEN
        action: @\parse_table

  parse_named_type: =>
    named_type @expect T_NAME

  parse_string_type: =>
    StringType @expect T_STRING

  parse_array: =>
    {_, elem_type, _} = @sequence
      * token: T_BRACKET_OPEN
      * action: @\parse_type
      * token: T_BRACKET_CLOSE
    Array elem_type

  parse_tuple_or_function: =>
    @expect T_PAREN_OPEN
    local types
    if @maybe T_PAREN_CLOSE
      types = {}
    else
      {types, _} = @sequence
        * action: -> @parse_repeat_separated @\parse_type, T_COMMA
        * token: T_PAREN_CLOSE
    if not @maybe T_ARROW
      return Tuple types

    Function types, @parse_return_type!

  parse_return_type: =>
    @select
      * token: T_NAME
        action: ->
          ty = @parse_named_type!
          if ty.name == 'nil'
            {} -- 'nil' is an alternative spelling of '<>'
          else
            { ty }
      * token: T_ANGLE_OPEN
        action: ->
          @expect T_ANGLE_OPEN
          if @maybe  T_ANGLE_CLOSE
            return {}
          types = @parse_repeat_separated @\parse_type, T_COMMA
          @expect T_ANGLE_CLOSE
          types
      otherwise: ->
        { @parse_type! }

  parse_table: =>
    {_, table, _} = @sequence
      * token: T_BRACE_OPEN
      * action: @\parse_table_content
      * token: T_BRACE_CLOSE
    table

  parse_table_content: =>
    first_elem = @select
      * token: T_NAME
        action: -> @expect T_NAME
      * token: T_BRACE_CLOSE
        action: -> nil
      otherwise: @\parse_type
    if first_elem == nil
      return Struct {}

    second_elem = @select
      * token: T_BRACE_CLOSE
        action: -> 'set'
      * token: T_ARROW
        action: -> 'mapping'
      * token: T_COLON
        action: -> 'struct'

    switch second_elem
      when 'set'
        if 'string' == type first_elem
          first_elem = named_type first_elem
        Set first_elem
      when 'mapping'
        if 'string' == type first_elem
          first_elem = named_type first_elem
        { _, maps_to } = @sequence
          * token: T_ARROW
          * action: @\parse_type
        Mapping first_elem, maps_to
      when 'struct'
        @expect T_COLON
        first_type = @parse_type!
        first_field = Field first_elem, first_type
        if @lexer\peek!.type == T_COMMA
          @expect T_COMMA
        remainder = @select
          * token: T_BRACE_CLOSE
            action: -> nil
          * token: T_NAME
            action: -> @parse_repeat_separated @\parse_field, T_COMMA
        if remainder?
          Struct { first_field, ...remainder}
        else
          Struct { first_field }
      else
        error "internal error: unexpected symbol: #{repr second_elem}"

  parse_field: =>
    {name, _, type} = @sequence
      * token: T_NAME
      * token: T_COLON
      * action: @\parse_type
    Field name, type

-- Tokens
T_PAREN_OPEN = <tostring>: => "'('"
T_PAREN_CLOSE = <tostring>: => "')'"
T_BRACE_OPEN = <tostring>: => "'{'"
T_BRACE_CLOSE = <tostring>: => "'}'"
T_BRACKET_OPEN = <tostring>: => "'['"
T_BRACKET_CLOSE = <tostring>: => "']'"
T_ANGLE_OPEN = <tostring>: => '"<"'
T_ANGLE_CLOSE = <tostring>: => '">"'
T_COMMA = <tostring>: => "','"
T_COLON = <tostring>: => "':'"
T_ARROW = <tostring>: => "'->'"
T_QUESTION = <tostring>: => "'?'"
T_PLUS = <tostring>: => "'+'"
T_PIPE = <tostring>: => "'|'"
T_NAME = <tostring>: => "<name>"
T_STRING = <tostring>: => "<string>"

class Lexer
  new: (type_spec) =>
    @index = 1
    @done = false
    @peeked = nil
    @tokens = coroutine.wrap ->
      while @index <= #type_spec
        ty, value, bytes_consumed = if whitespace = type_spec\match '^[ \t\r\n]+', @index
          nil, nil, #whitespace
        else if match = type_spec\match '^%(', @index
          T_PAREN_OPEN, nil, #match
        else if match = type_spec\match '^%)', @index
          T_PAREN_CLOSE, nil, #match
        else if match = type_spec\match '^,', @index
          T_COMMA, nil, #match
        else if match = type_spec\match '^{', @index
          T_BRACE_OPEN, nil, #match
        else if match = type_spec\match '^}', @index
          T_BRACE_CLOSE, nil, #match
        else if match = type_spec\match '^%[', @index
          T_BRACKET_OPEN, nil, #match
        else if match = type_spec\match '^]', @index
          T_BRACKET_CLOSE, nil, #match
        else if match = type_spec\match '^:', @index
          T_COLON, nil, #match
        else if match = type_spec\match '^->', @index
          T_ARROW, nil, #match
        else if match = type_spec\match '^<', @index
          T_ANGLE_OPEN, nil, #match
        else if match = type_spec\match '^>', @index
          T_ANGLE_CLOSE, nil, #match
        else if match = type_spec\match '^?', @index
          T_QUESTION, nil, #match
        else if match = type_spec\match '^+', @index
          T_PLUS, nil, #match
        else if match = type_spec\match '^|', @index
          T_PIPE, nil, #match
        else if name = type_spec\match '^([a-zA-Z_][a-zA-Z0-9_]*)', @index
          T_NAME, name, #name
        else if string = type_spec\match [[^"([^"]*)"]], @index
          T_STRING, string, #string + 2
        else
          error "unrecognised character '#{type_spec\sub @index, @index}' in type spec '#{type_spec}"

        @index += bytes_consumed
        if not ty?
          continue
        coroutine.yield Symbol ty, value

  peek: =>
    if @done
      return nil

    if @peeked?
      return @peeked

    @peeked = @tokens!
    if not @peeked
      @done = true
    @peeked

  next: =>
    if @done
      return nil

    if @peeked?
      peeked = @peeked
      @peeked = nil
      peeked
    else
      ret = @tokens!
      if not ret?
        @done = true
      ret

  snapshot: =>
    Snapshot @index, @peeked

  restore: (snapshot) =>
    { :index, :peeked } = snapshot
    @index = index
    @peeked = peeked

class Snapshot
  new: (@index, @peeked) =>

class Symbol
  new: (@type, @value=nil) =>

  __tostring: =>
    if @value?
      "#{@type}(#{@value})"
    else
      "#{@type}"

known_primitives =
  nil: true
  boolean: true
  number: true
  string: true
  function: true
  table: true
  thread: true
named_type = (name) ->
  if not name.match?
    error repr name
  if known_primitives[name]?
    Primitive name
  else if name == 'any'
    Any!
  else if not name\match '^[A-Z]'
    error "cannot use '#{name}' as user type name: name must start with an uppercase letter"
  else
    UserType name

class Primitive
  new: (@name) =>

  __tostring: => @name

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, @name

class Any
  __tostring: =>
    'any'

  checker: (checker_builder=CheckerBuilder!) =>
    checker_builder -- No checks required.

class UserType
  new: (@name) =>

  __tostring: => @name

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      parsed_user_type = user_types[@name]
      if not parsed_user_type? or checker_builder\already_building @
        \add C_PUSH_CHECKER, @name
      else
        \push_building @
        parsed_user_type\checker checker_builder
        \pop_building @

class StringType
  new: (@content) =>

  __tostring: =>
    "\"#{@content}\""

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'string'
      \add C_ASSERT_EQ, @content

class Optional
  new: (@inner_type) =>

  __tostring: =>
    "?#{@inner_type}"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      inner_skip_target = \add_with_unresolved_target C_JMP_IF_NIL
      @inner_type\checker checker_builder
      inner_skip_target\resolve_here!

class Array
  new: (@elem_type) =>

  __tostring: =>
    "[#{@elem_type}]"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'table'
      \add C_PUSH, 1

      loop_start = \add_labelled C_GET_FIELD

      loop_exit_target = \add_with_unresolved_target C_JMP_IF_NIL
      @elem_type\checker checker_builder
      \add C_POP
      \add C_INCR
      \add C_JMP, loop_start.index

      loop_exit_target\resolve_here!
      \add C_POP
      \add C_DECR
      \add C_ASSERT_LEN
      \add C_POP

class Tuple
  new: (@elem_types) =>

  __tostring: =>
    elem_type_reprs = [ tostring elem_type for elem_type in *@elem_types ]
    "(#{table.concat elem_type_reprs, ', '})"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'table'
      for i = 1, #@elem_types
        \add C_PUSH, i
        \add C_GET_FIELD
        @elem_types[i]\checker checker_builder
        \add C_POP
        \add C_POP

class Struct
  new: (@fields) =>

  __tostring: =>
    field_reprs = [ tostring field for field in *@fields ]
    "{#{table.concat field_reprs, ', '}}"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'table'
      for field in *@fields
        \add C_PUSH, field.name
        \add C_GET_FIELD
        field\checker checker_builder
        \add C_POP
        \add C_POP

class Field
  new: (@name, @type) =>

  __tostring: =>
    "#{@name}: #{@type}"

  checker: (checker_builder=CheckerBuilder!) =>
    @type\checker checker_builder

class Set
  new: (@elem_type) =>

  __tostring: =>
    "{#{@elem_type}}"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'table'
      \add C_PUSH, V_NIL
      \add C_NEXT

      loop_start_label = \add_with_unresolved_target C_JMP_IF_NIL
      \add C_ASSERT_TRUTHY
      \add C_POP
      @elem_type\checker checker_builder

      \add C_NEXT
      \add C_JMP, loop_start_label.index

      loop_start_label\resolve_here!
      \add C_POP
      \add C_POP

class Mapping
  new: (@in_type, @out_type) =>

  __tostring: =>
    "{#{@in_type} -> #{@out_type}}"

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'table'
      \add C_PUSH, V_NIL
      \add C_NEXT

      loop_start_label = \add_with_unresolved_target C_JMP_IF_NIL

      @out_type\checker checker_builder
      \add C_POP
      @in_type\checker checker_builder

      \add C_NEXT
      \add C_JMP, loop_start_label.index

      loop_start_label\resolve_here!
      \add C_POP
      \add C_POP


class Function
  new: (@param_types, @return_types) =>
    @_param_checkers = nil
    @_return_checkers = nil

  param_checkers: =>
    if param_checkers = @_param_checkers
      return param_checkers
    param_checkers = with {}
      for param_type in *@param_types
        [] = param_type\checker!\build!
    @_param_checkers = param_checkers
    param_checkers

  return_checkers: =>
    if return_checkers = @_return_checkers
      return return_checkers
    return_checkers = with {}
      for return_type in *@return_types
        [] = return_type\checker!\build!
    @_return_checkers = return_checkers
    return_checkers

  __tostring: =>
    table.concat with {}
      [] = '('
      first = true
      for param_type in *@param_types
        if not first
          [] = ", "
        first = false

        [] = tostring param_type
      [] = ') -> '
      if #@return_types == 1
        [] = tostring @return_types[1]
      else
        [] = '<'
        first = true
        for return_type in *@return_types
          if not first
            [] = ", "
          first = false
          [] = tostring return_type
        [] = '>'

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      \add C_ASSERT_PRIMITIVE, 'function'

class Disjunction
  new: (@types) =>

  __tostring: =>
    table.concat [tostring ty for ty in *@types], '|'

class Conjunction
  new: (@types) =>

  __tostring: =>
    table.concat [tostring ty for ty in *@types], '+'

  checker: (checker_builder=CheckerBuilder!) =>
    with checker_builder
      for ty in *@types
        ty\checker checker_builder

class CheckerBuilder
  new: =>
    @instructions = {}
    @user_type_stack = {}

  add: (op, arg='_') =>
    @instructions[] = op
    @instructions[] = arg

  add_labelled: (op, arg='_') =>
    label = @make_label!
    @add op, arg
    label

  add_with_unresolved_target: (op) =>
    label = @make_label!
    @add op, LABEL_PLACEHOLDER
    label

  make_label: =>
    Label @instructions

  build: =>
    @validate!
    @instructions

  validate: =>
    for instruction in *@instructions
      if instruction == LABEL_PLACEHOLDER
        error "unresolved placeholder in check program:\n#{repr @instructions}"

  already_building: (user_type) =>
    for user_type_being_checked in *@user_type_stack
      if user_type.name == user_type_being_checked.name
        return true
    false

  push_building: (user_type) =>
    @user_type_stack[] = user_type

  pop_building: (user_type) =>
    if @user_type_stack[#@user_type_stack] != user_type
      error "internal error: user type stack mismanaged, expected #{user_type.name} at the top of #{repr @user_type_stack}"
    @user_type_stack[#@user_type_stack] = nil

class Label
  new: (@instructions) =>
    @index = #@instructions + 1

  resolve_here: =>
    @instructions[@index + 1] = #@instructions + 1

C_PUSH = <tostring>: => '<push>'
C_POP = <tostring>: => '<pop>'
C_ASSERT_PRIMITIVE = <tostring>: => '<assert-primitive>'
C_ASSERT_TRUTHY = <tostring>: => '<assert-truthy>'
C_ASSERT_LEN = <tostring>: => '<assert-len>'
C_ASSERT_EQ = <tostring>: => '<assert-eq>'
C_GET_FIELD = <tostring>: => '<field>'
C_INCR = <tostring>: => '<incr>'
C_DECR = <tostring>: => '<decr>'
C_NEXT = <tostring>: => '<next>'
C_JMP = <tostring>: => '<jmp>'
C_JMP_IF_NIL = <tostring>: => '<jnil>'
C_PUSH_CHECKER = <tostring>: => '<push-checker>'
V_NIL = <tostring>: => 'nil'

checker_program_repr = (checker) ->
  table.concat ["#{i}:\t#{repr checker[i]}\t#{checker[i+1]}" for i = 1, #checker, 2], '\n\t'

LABEL_PLACEHOLDER = <tostring>: => '<LABEL-PLACEHOLDER>'

stack_size = 0
stack = {}
num_running_checkers = 0
check_error = (...) ->
  for i = 1, stack_size
    stack[i] = nil
  stack_size = 0
  num_running_checkers = 0
  error ...

instruction_counts = {}

export MAX_CHECKER_DEPTH = 1000
check = (check_prog, value, root=true) ->
  if root
    -- Prime stack.
    stack_size = 1
    stack[1] = value
    num_running_checkers = 0
  initial_stack_size = stack_size

  initial_num_running_checkers = num_running_checkers
  num_running_checkers += 1

  if num_running_checkers >= MAX_CHECKER_DEPTH
    error "type checker recursed too many times (#{num_running_checkers} times). If this is okay, increase the MAX_CHECKER_DEPTH"

  with check_prog
    local pc = -1
    n_instructions = #check_prog
    while true
      pc += 2
      if pc >= n_instructions
        break

      instruction = [pc]
      if COLLECT_STATS
        instruction_counts[instruction] = if v = instruction_counts[instruction]
          v + 1
        else
          1

      if DEBUG
        print "stack state #{instruction}@#{pc} [#{stack_size}]:\n\t#{table.concat [ "#{i}:\t#{repr stack[i]}" for i = 1, stack_size], '\n\t'}"

      switch instruction
        when C_PUSH
          arg = [pc + 1]
          if arg == V_NIL
            arg = nil
          stack_size += 1
          stack[stack_size] = arg
        when C_POP
          stack[stack_size] = nil
          stack_size -= 1
        when C_ASSERT_PRIMITIVE
          ty = type stack[stack_size]
          arg = [pc + 1]
          if ty != arg
            check_error "incorrect type: expected #{arg} but got #{ty}"
        when C_ASSERT_TRUTHY
          if not stack[stack_size]
            check_error "incorrect type: expected a truthy value but got #{stack[stack_size]}"
        when C_ASSERT_LEN
          actual_len = #stack[stack_size-1]
          counted_len = stack[stack_size]
          if counted_len != actual_len
            check_error "incorrect type: expected array but got table"
        when C_ASSERT_EQ
          if stack[stack_size] != [pc + 1]
            check_error "incorrect type: expected #{type [pc + 1]} #{repr [pc + 1]}"
        when C_GET_FIELD
          stack_size += 1
          stack[stack_size] = stack[stack_size-2][stack[stack_size-1]]
        when C_INCR
          stack[stack_size] += 1
        when C_DECR
          stack[stack_size] -= 1
        when C_NEXT
          tab = stack[stack_size-1]
          idx = stack[stack_size]
          next_idx, value = next tab, idx
          stack[stack_size] = next_idx
          stack_size += 1
          stack[stack_size] = value
        when C_JMP
          pc = [pc + 1] - 2
        when C_JMP_IF_NIL
          if not stack[stack_size]?
            pc = [pc + 1] - 2
        when C_PUSH_CHECKER
          arg = [pc + 1]
          checker = type_checkers[arg]
          if not checker?
            error "cannot typecheck #{arg}: type not defined"
          check checker, nil, false
        else
          check_error "internal error: illegal type-checker VM instruction #{[pc]}@#{pc}"
    if DEBUG
      print "FINAL stack state #{check_prog[pc-2]}@#{pc-2} [#{stack_size}]:\n\t#{table.concat [ "#{i}:\t#{repr stack[i]}" for i = 1, stack_size], '\n\t'}"

    num_running_checkers -= 1
    assert num_running_checkers == initial_num_running_checkers, "internal error: checker depth incorrectly handled: expected #{initial_num_running_checkers} but got #{num_running_checkers}"
    assert stack_size == initial_stack_size, "internal error: value stack incorrectly handled"
    if root
      -- Reset stack.
      stack[1] = nil
      stack_size = 0
  nil

user_types = {}
export declare_type = (name, type_spec) ->
  if not name?
    error "declare_type requires a name"
  if 'string' != type name
    error "declare_type requires a string name"
  if not type_spec?
    error "declare_type requires a type_spec"
  if 'string' != type type_spec
    error "declare_type requires a string type_spec"

  if not (name\sub 1, 1)\match '^[A-Z_]$'
    error "cannot declare type '#{name}': user types must start with uppercase or '_'"
  if user_types[name]?
    error "cannot redefine type '#{name}'"
  parsed_type = parse type_spec
  user_types[name] = parsed_type
  type_checkers[name] = parsed_type\checker!\build!

export deactivate = ->
  T = (_, value) -> value
  F = (_, fn) ->

export stats = ->
  stats_arr = [:instruction, :count for instruction, count in pairs instruction_counts]
  table.sort stats_arr, (a, b) -> a.count > b.count
  stats_arr

spec ->
  import assert_that, expect_that, describe, it, matchers from require 'spec'
  import anything, contains_value, deep_eq, each_value, eq, errors, fields, ge, gt, len, match, matches, no_errors from matchers

  describe 'Lexer', ->
    tokens = (raw) ->
      assert raw
      with {}
        for token in (Lexer raw).tokens
          [] = token

    it 'emits simple types', ->
      simple_types =
        * type nil
        * type false
        * type 0
        * type ""
        * type ->
        * type coroutine.create ->
        * 'any'
      for simple_type in *simple_types
        expect_that (tokens simple_type), deep_eq {
          Symbol T_NAME, simple_type
        }

    it 'emits string types', ->
      expect_that (tokens '"hello" "world"'), deep_eq {
        Symbol T_STRING, 'hello'
        Symbol T_STRING, 'world'
      }

    it 'emits strucural tokens', ->
      expect_that (tokens '(),{}[]:->?+|'), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_PAREN_CLOSE
        Symbol T_COMMA
        Symbol T_BRACE_OPEN
        Symbol T_BRACE_CLOSE
        Symbol T_BRACKET_OPEN
        Symbol T_BRACKET_CLOSE
        Symbol T_COLON
        Symbol T_ARROW
        Symbol T_QUESTION
        Symbol T_PLUS
        Symbol T_PIPE
      }

    it 'ignores whitespace', ->
      expect_that (tokens ' (\tstring\r)\n-> string '), deep_eq {
        Symbol T_PAREN_OPEN
        Symbol T_NAME, "string"
        Symbol T_PAREN_CLOSE
        Symbol T_ARROW
        Symbol T_NAME, "string"
      }

    it 'rejects unrecognised characters', ->
      expect_that (-> tokens '@'), errors matches [[unrecognised character '@']]
      expect_that (-> tokens '1'), errors matches [[unrecognised character '1']]

    describe ':peek', ->
      it 'matches :next', ->
        lexer = Lexer '()'
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\next!, deep_eq Symbol T_PAREN_OPEN
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\peek!, deep_eq Symbol T_PAREN_CLOSE
        assert_that lexer\next!, deep_eq Symbol T_PAREN_CLOSE

      it 'returns nil at EOF', ->
        lexer = Lexer ''
        expect_that lexer\peek!, eq nil
        expect_that lexer\peek!, eq nil

  describe 'Parser', ->
    describe 'run on simple types', ->
      it 'accepts primitives', ->
        expect_that (parse 'nil'), deep_eq Primitive type nil
        expect_that (parse 'number'), deep_eq Primitive type 0
        expect_that (parse 'number'), deep_eq Primitive type 0.0
        expect_that (parse 'string'), deep_eq Primitive type ""
        expect_that (parse 'table'), deep_eq Primitive type {}
        expect_that (parse 'function'), deep_eq Primitive type ->
        expect_that (parse 'thread'), deep_eq Primitive type coroutine.create ->
        expect_that (parse 'any'), deep_eq Any!

      it 'accepts user types', ->
        expect_that (parse 'UserType'), deep_eq UserType 'UserType'

      it 'accepts string types', ->
        expect_that (parse '"hello"'), deep_eq StringType 'hello'

      it 'rejects unknown primitives', ->
        expect_that (-> parse 'user'), errors matches [[cannot use 'user' as user type name: name must start with an uppercase letter]]

      it 'rejects incomplete types', ->
        expect_that (-> parse '['), errors matches [[unexpected EOF]]

      it 'rejects inputs with trailing errors', ->
        expect_that (-> parse 'string]'), errors matches 'type spec has trailing characters'

    describe 'run on composite types', ->
      it 'accepts optional', ->
        expect_that (parse '?nil'), deep_eq Optional Primitive 'nil'
        expect_that (parse '?string'), deep_eq Optional Primitive 'string'
        expect_that (parse '?() -> nil'), deep_eq Optional Function {}, {}

      it 'accepts arrays', ->
        expect_that (parse '[string]'), deep_eq Array Primitive 'string'
        expect_that (parse '[[string]]'), deep_eq Array Array Primitive 'string'

      it 'accepts tuples', ->
        expect_that (parse '()'), deep_eq Tuple {}
        expect_that (parse '(nil, number)'), deep_eq Tuple { (Primitive 'nil'), Primitive 'number' }
        expect_that (parse '((nil, number), string, (User, table))'), deep_eq Tuple {
          Tuple { (Primitive 'nil'), (Primitive 'number') },
          Primitive 'string',
          Tuple { (UserType 'User'), (Primitive 'table') },
        }

      it 'accepts sets', ->
        expect_that (parse '{string}'), deep_eq Set Primitive 'string'
        expect_that (parse '{{string}}'), deep_eq Set Set Primitive 'string'

      it 'accepts mappings', ->
        expect_that (parse '{boolean -> number}'), deep_eq Mapping (Primitive 'boolean'), Primitive 'number'
        expect_that (parse '{{boolean -> number} -> {string -> thread}}'), deep_eq Mapping (Mapping (Primitive 'boolean'), Primitive 'number'), Mapping (Primitive 'string'), Primitive 'thread'

      it 'accepts structs', ->
        expect_that (parse '{}'), deep_eq Struct {}
        expect_that (parse '{field: boolean}'), deep_eq Struct
          * Field 'field', Primitive 'boolean'
        expect_that (parse '{field1: number, field2: string}'), deep_eq Struct
          * Field 'field1', Primitive 'number'
          * Field 'field2', Primitive 'string'
        expect_that (parse '{outer1: {inner1: boolean}, outer2: {inner2: boolean}}'), deep_eq Struct
          * Field 'outer1', Struct
            * Field 'inner1', Primitive 'boolean'
          * Field 'outer2', Struct
            * Field 'inner2', Primitive 'boolean'

      it 'accepts functions', ->
        expect_that (parse '() -> nil'), deep_eq Function {}, {}
        expect_that (parse '() -> <>'), deep_eq Function {}, {}
        expect_that (parse '(string) -> number'), deep_eq Function {Primitive 'string'}, {Primitive 'number'}
        expect_that (parse '(number, string) -> number'), deep_eq Function {(Primitive 'number'), (Primitive 'string')}, {Primitive 'number'}
        expect_that (parse '(string) -> (number) -> boolean'), deep_eq Function {Primitive 'string'}, {Function {Primitive 'number'}, {Primitive 'boolean'}}
        expect_that (parse '() -> <string>'), deep_eq Function {}, {(Primitive 'string')}
        expect_that (parse '() -> <string, boolean>'), deep_eq Function {}, {(Primitive 'string'), (Primitive 'boolean')}

      it 'accepts conjunctions', ->
        expect_that (parse '[string]+{number->string}+table+function'), deep_eq Conjunction
          * Array Primitive 'string'
          * Mapping (Primitive 'number'), Primitive 'string'
          * Primitive 'table'
          * Primitive 'function'

      it 'accepts disjunctions', ->
        expect_that (parse '[string]|{number->string}|table|function'), deep_eq Disjunction
          * Array Primitive 'string'
          * Mapping (Primitive 'number'), Primitive 'string'
          * Primitive 'table'
          * Primitive 'function'

      it 'gives precedence to conjunctions', ->
        expect_that (parse 'string+number|boolean'), deep_eq Disjunction
          * Conjunction
            * Primitive 'string'
            * Primitive 'number'
          * Primitive 'boolean'
        expect_that (parse 'string|number+boolean'), deep_eq Disjunction
          * Primitive 'string'
          * Conjunction
            * Primitive 'number'
            * Primitive 'boolean'

  describe 'T', ->
    it 'requires two arguments', ->
      expect_that (-> T!), errors matches 'cannot typecheck: no type spec provided'

    it 'returns its second argument', ->
      value = {}
      expect_that (T '{}', value), eq value

    it 'checks primitives', ->
      expect_that (-> T 'nil', nil), no_errors!
      expect_that (-> T 'number', 123), no_errors!
      expect_that (-> T 'string', 'some-string'), no_errors!

      expect_that (-> T 'nil', 123), errors matches 'incorrect type: expected nil but got number'
      expect_that (-> T 'number', nil), errors matches 'incorrect type: expected number but got nil'
      expect_that (-> T 'string', 123), errors matches 'incorrect type: expected string but got number'

    it 'checks any', ->
      values =
        * 123
        * 'str'
        * {}
        * ->
        * coroutine.create ->
      for value in *values
        expect_that (-> T 'any', value), no_errors!

    it 'checks string types', ->
      expect_that (-> T '"hello"', 'hello'), no_errors!
      expect_that (-> T '"hello"', 'world'), errors matches "incorrect type: expected string 'hello'"

    it 'checks optionals', ->
      expect_that (-> T '?number', nil), no_errors!
      expect_that (-> T '?number', 123), no_errors!
      expect_that (-> T '?number', 'str'), errors matches 'incorrect type: expected number but got string'
      expect_that (-> T '?(number)', 'str'), errors matches 'incorrect type: expected table but got string'

    it 'checks arrays', ->
      expect_that (-> T '[number]', {}), no_errors!
      expect_that (-> T '[number]', {123, 312}), no_errors!
      expect_that (-> T '[[number]]', {{123}, {312}}), no_errors!

      expect_that (-> T '[string]', 123), errors matches 'incorrect type: expected table but got number'
      expect_that (-> T '[[number]]', {{123}, {'asdf'}}), errors matches 'incorrect type: expected number but got string'

      hybrid = {123, 456, 789, field: 'a'}
      if #hybrid != 3
        expect_that (-> T '[string]', hybrid), no_errors!
      else
        expect_that (-> T '[string]', hybrid), errors matches 'incorrect type: expected string but got number'

    it 'checks tuples', ->
      expect_that (-> T '()', {}), no_errors!
      expect_that (-> T '(number, boolean, string)', {123, true, 'hello'}), no_errors!
      expect_that (-> T '(number, boolean, string)', {123, true, 'hello', coroutine.create ->}), no_errors!
      expect_that (-> T '((number, boolean), (string, thread))', {{123, true}, {'hello', coroutine.create ->}}), no_errors!

      expect_that (-> T '(number, boolean, string)', nil), errors matches 'incorrect type: expected table but got nil'
      expect_that (-> T '(number, boolean, string)', {}), errors matches 'incorrect type: expected number but got nil'
      expect_that (-> T '(number, boolean, string)', {123}), errors matches 'incorrect type: expected boolean but got nil'
      expect_that (-> T '(number, boolean, string)', {'interloper'}), errors matches 'incorrect type: expected number but got string'

    it 'checks sets', ->
      expect_that (-> T '{number}', {}), no_errors!
      expect_that (-> T '{number}', {[123]: true, [321]: {}}), no_errors!
      expect_that (-> T '{{number}}', {[{123}]: true}), no_errors!

      expect_that (-> T '{number}', nil), errors matches 'incorrect type: expected table but got nil'
      expect_that (-> T '{number}', {[123]: false}), errors matches 'incorrect type: expected a truthy value but got false'
      expect_that (-> T '{{number}}', {[{['asdf']: true}]: true}), errors matches 'incorrect type: expected number but got string'

    it 'checks mappings', ->
      expect_that (-> T '{string -> number}', {}), no_errors!
      expect_that (-> T '{number -> string}', {'hello', [10]: 'world'}), no_errors!
      expect_that (-> T '{{boolean -> number} -> {string -> thread}}', {[{[true]: 123}]: {asdf: coroutine.create ->}}), no_errors!

      expect_that (-> T '{number -> string}', nil), errors matches 'incorrect type: expected table but got nil'
      expect_that (-> T '{number -> string}', {123}), errors matches 'incorrect type: expected string but got number'
      expect_that (-> T '{number -> string}', {'hello', 'world', 'foo', 'bar', 'baz', 123}), errors matches 'incorrect type: expected string but got number'

    it 'checks structs', ->
      expect_that (-> T '{}', {}), no_errors!
      expect_that (-> T '{}', {123}), no_errors!
      expect_that (-> T '{}', {hello: 123}), no_errors!
      expect_that (-> T '{hello: string}', {hello: 'hello'}), no_errors!
      expect_that (-> T '{hello: {world: string}}', {hello: world: 'world'}), no_errors!
      expect_that (-> T '{hello: {world: string}, foo: boolean}', hello: {world:'asdf'}, foo: true), no_errors!

      expect_that (-> T '{}', 132), errors matches 'incorrect type: expected table but got number'
      expect_that (-> T '{hello: string}', {}), errors matches 'incorrect type: expected string but got nil'
      expect_that (-> T '{hello: string}', hello: 123), errors matches 'incorrect type: expected string but got number'
      expect_that (-> T '{hello: {world: string}}', hello: 123), errors matches 'incorrect type: expected table but got number'
      expect_that (-> T '{hello: {world: string}}', hello: {}), errors matches 'incorrect type: expected string but got nil'
      expect_that (-> T '{hello: {world: string}}', hello: world: 123), errors matches 'incorrect type: expected string but got number'
      expect_that (-> T '{hello: {world: string}, foo: boolean}', hello: {world:'asdf'}, foo: 123), errors matches 'incorrect type: expected boolean but got number'

    it 'checks functions', ->
      expect_that (-> T '() -> nil', ->), no_errors!
      expect_that (-> T '() -> nil', -> nil), no_errors!
      expect_that (-> T '() -> nil', {}), errors matches 'incorrect type: expected function but got table'

    it 'checks conjunctions', ->
      expect_that (-> T '[string]+{number}', {'a', 'b', 'c'}), no_errors!

      expect_that (-> T 'string+number', 123), errors matches 'incorrect type: expected string but got number'
      expect_that (-> T 'string+number', 'hello'), errors matches 'incorrect type: expected number but got string'

  describe 'declare_type', ->
    it 'requires two arguments', ->
      expect_that (-> declare_type!), errors matches 'declare_type requires a name'
      expect_that (-> declare_type 'TwoArgs'), errors matches 'declare_type requires a type_spec'
      expect_that (-> declare_type 123, 'string'), errors matches 'declare_type requires a string name'
      expect_that (-> declare_type 'TwoArgs', 123), errors matches 'declare_type requires a string type_spec'

    it 'rejects false primitives', ->
      expect_that (-> declare_type 'user', 'string'), errors matches 'user types must start with uppercase'

    it 'rejects redefinition', ->
      declare_type 'AlreadyDefined', 'number'
      expect_that (-> declare_type 'AlreadyDefined', 'string'), errors matches [[cannot redefine type 'AlreadyDefined']]

    it 'supports non-recursive types', ->
      declare_type 'NonRecursive', '[string]'
      expect_that (-> T '[NonRecursive]', {{'hello'}}), no_errors!

    it 'supports recursive types', ->
      declare_type 'Recursive', '[?Recursive]'
      expect_that (-> T 'Recursive', {{{{{nil}}}}}), no_errors!
      expect_that (-> T 'Recursive', {{{{{'asdf'}}}}}), errors matches 'incorrect type: expected table but got string'

      declare_type 'MutuallyRecursive1', '?MutuallyRecursive2'
      declare_type 'MutuallyRecursive2', 'MutuallyRecursive1'
      expect_that (-> T 'MutuallyRecursive1', nil), no_errors!
      expect_that (-> T 'MutuallyRecursive1', 'asdf'), errors matches 'type checker recursed too many times'

  describe 'F', ->
    it 'requires two arguments', ->
      expect_that (-> F!), errors matches 'cannot typecheck: no type spec provided'
      expect_that (-> F '() -> nil'), errors matches 'cannot typecheck: no function provided'
      expect_that (-> F '() -> nil', 'interloper'), errors matches 'cannot typecheck: no function provided'

    it 'returns its second argument', ->
      f = F '(number, number) -> number', (a, b) -> a + b
      expect_that (f 1, 2), eq 3

    it 'accepts nil returns', ->
      expect_that (-> (F '() -> nil', ->)!), no_errors!

    it 'accepts absent optional arguments', ->
      expect_that (-> (F '() -> ?string', ->)!), no_errors!

    it 'accepts absent optional retunsr', ->
      expect_that (-> (F '() -> nil', ->)!), no_errors!

    it 'accepts multiple return values', ->
      expect_that (-> (F '() -> <string, boolean>', -> 'a', true)!), no_errors!

    it 'rejects non-function types', ->
      expect_that (-> F '{}', ->), errors matches 'cannot typecheck: expected a function type'

    it 'rejects incorrect-type arguments', ->
      expect_that (-> (F '(string) -> table', ->) 123), errors matches 'incorrect type: expected string but got number'

    it 'rejects extra arguments', ->
      expect_that (-> (F '(string) -> table', ->) 'a', 'b'), errors matches 'function passed too many arguments'

    it 'rejects incorrect-type return values', ->
      expect_that (-> (F '(table) -> string', ->) {}), errors matches 'incorrect type: expected string but got nil'

    it 'rejects extra return arguments', ->
      expect_that (-> (F '() -> string', -> 'a', 'b')!), errors matches 'function returned too many values'

    it 'rejects multiple incorrect return values', ->
      expect_that (-> (F '() -> <string, boolean>', -> {}, true)!), errors matches 'incorrect type: expected string but got table'
      expect_that (-> (F '() -> <string, boolean>', -> 'asdf', {})!), errors matches 'incorrect type: expected boolean but got table'

  describe 'stats', ->
    it 'has the correct type', ->
      prev_collect_stats = COLLECT_STATS
      COLLECT_STATS = true

      T 'string', 'hello' -- Exercise the checker
      stats_arr = stats!
      expect_that stats_arr, len gt 0
      expect_that stats_arr, each_value fields count: ge 0

      COLLECT_STATS = prev_collect_stats

-- import set_log_verbosity from require 'fat.logger'
-- set_log_verbosity true
DEBUG = true
(require 'spec').run_tests select 1, ...
