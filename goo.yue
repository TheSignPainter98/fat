local *

import ArgParser, Subcommand, Param, Flag from require 'clap'

FILE_DIVIDER = (os.getenv? 'GOO_DIVIDER') ?? 'XXX---XXX===fdhsavcuyxio4321vdcp1234nhuvd---XXX===XXX'

local log

main = (args) ->
  args, ok = parse_args args
  if not ok
    return

  log = if args.verbose
    print
  else
    ->

  if ball_args = args.ball
    ball ball_args
  if splat_args = args.splat
    splat splat_args

parse_args = (args) ->
  parser = with ArgParser 'goo'
    \version '1.0'
    \description 'an archiving utility'
    \add with Flag 'verbose'
      \description 'output verbosely'
    \add with Subcommand 'ball'
      \description 'create the given archive with the specified files'
      \add with Param 'archive'
        \description 'the archive to extract files from'
      \add with Param 'pattern'
        \description 'directory or filter for archived files'
      \add with Flag 'only'
        \takes_param!
        \default nil
        \description 'only archive files matching the given glob'
    \add with Subcommand 'splat'
      \description 'extract from the given archive'
      \add with Param 'archive'
        \description 'the archive to extract files from'
  parser\parse args

ball = (ball_args) ->
  try
    paths = do
      pattern = ball_args.pattern
      pattern_is_glob = pattern\match '[*?]'
      if pattern_is_glob
        if ball_args.pattern\match '/'
          fs.find pattern
        else
          file_paths_in '.', pattern
      else if fs.isDir pattern
        file_paths_in pattern
      else
        error "cannot archive directory #{ball_args.dir}"

    archive_file, err = io.open ball_args.archive, 'w+'
    if not archive_file?
      error "cannot open #{archive_file}: #{err}"

    for path in *paths
      log "archiving #{path}..."
      archive_file\write path .. '\n'
      for line in io.lines path
        if line == FILE_DIVIDER
          error "cannot put #{path} into archive: file divider found"
        archive_file\write line .. '\n'
      archive_file\write FILE_DIVIDER .. '\n'

    archive_file\close!
  catch err
    os.remove ball_args.archive
    print err

file_paths_in = (dir, name_pattern=nil, ret={}) ->
  with ret
    if name_pattern?
      for name in *fs.find fs.combine dir, name_pattern
        if fs.isDir name
          continue
        [] = name

    for name in *fs.list dir
      path = fs.combine dir, name
      if fs.isDir path
        file_paths_in path, name_pattern, ret
      else if not name_pattern?
        [] = path

splat = (splat_args) ->
  files = {}

  try
    scanning_header = true
    current_file = nil
    for line in io.lines splat_args.archive
      if line == FILE_DIVIDER
        scanning_header = true
        continue

      if scanning_header
        if current_file?
          current_file\close!

        for i = 1, #line
          if '/' != line\sub i, i
            continue
          parent_dir = line\sub 0, i
          if not fs.exists parent_dir
            fs.makeDir parent_dir

        current_file, err = io.open line, 'w+'
        files[] = line
        log "extracting #{line}..."
        if not current_file?
          error "cannot open '#{line}': #{err}"
        scanning_header = false
        continue

      current_file\write line .. '\n'
  catch err
    for file in *files
      os.remove file

if not _G.fs?
  _G.fs =
    list: (dir) ->
      ret = {}
      with io.popen "ls -1 '#{dir}'"
        ret = [ file for file in \lines! ]
        \close!
      ret

    find: (pattern) ->
      ret = {}
      with io.popen "bash -c \"ls -1 #{pattern} 2>/dev/null\""
        ret = [ path for path in \lines! when #path != 0 ]
        \close!
      ret

    combine: (path1, path2) ->
      "#{path1}/#{path2}" -- Good enough.

    isDir: (path) ->
      local resp
      with io.popen "[ -d '#{path}' ] && echo true || echo false"
        resp = \read '*a'
        \close!
      (resp\match 'true')?

    exists: (path) ->
      handle = io.open path, 'r'
      if handle?
        handle\close!
      handle?

    makeDir: (path) ->
      os.execute "mkdir '#{path}'"

main {...}
